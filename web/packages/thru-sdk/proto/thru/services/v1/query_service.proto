syntax = "proto3";

package thru.services.v1;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/api/client.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "thru/common/v1/consensus.proto";
import "thru/common/v1/filters.proto";
import "thru/common/v1/pagination.proto";
import "thru/common/v1/primitives.proto";
import "thru/core/v1/account.proto";
import "thru/core/v1/block.proto";
import "thru/core/v1/state.proto";
import "thru/core/v1/transaction.proto";
import "thru/core/v1/types.proto";

option go_package = "github.com/Unto-Labs/thru-net/grpc/pkg/proto/thru/services/v1;servicesv1";
option java_multiple_files = true;
option java_package = "network.thru.services.v1";
option csharp_namespace = "Thru.Services.V1";
option ruby_package = "Thru::Services::V1";
option objc_class_prefix = "THUS";
option swift_prefix = "THUS";

// GetAccountRequest retrieves a decoded account by public key.
message GetAccountRequest {
  thru.common.v1.Pubkey address = 1 [(google.api.field_behavior) = REQUIRED];
  optional thru.core.v1.AccountView view = 2 [(google.api.field_behavior) = OPTIONAL];
  thru.common.v1.VersionContext version_context = 3
      [(google.api.field_behavior) = REQUIRED];
  optional thru.common.v1.ConsensusStatus min_consensus = 4
      [(google.api.field_behavior) = OPTIONAL];
  optional thru.core.v1.DataSlice data_slice = 5
      [(google.api.field_behavior) = OPTIONAL];
}

// GetRawAccountRequest retrieves raw account bytes by public key.
message GetRawAccountRequest {
  thru.common.v1.Pubkey address = 1 [(google.api.field_behavior) = REQUIRED];
  optional thru.core.v1.AccountView view = 2 [(google.api.field_behavior) = OPTIONAL];
  thru.common.v1.VersionContext version_context = 3
      [(google.api.field_behavior) = REQUIRED];
  optional thru.common.v1.ConsensusStatus min_consensus = 4
      [(google.api.field_behavior) = OPTIONAL];
}

// GetTransactionRequest retrieves a decoded transaction by signature.
message GetTransactionRequest {
  thru.common.v1.Signature signature = 1 [(google.api.field_behavior) = REQUIRED];
  optional thru.core.v1.TransactionView view = 2 [(google.api.field_behavior) = OPTIONAL];
  thru.common.v1.VersionContext version_context = 3
      [(google.api.field_behavior) = REQUIRED];
  optional thru.common.v1.ConsensusStatus min_consensus = 4
      [(google.api.field_behavior) = OPTIONAL];
}

// GetRawTransactionRequest retrieves raw transaction bytes by signature.
message GetRawTransactionRequest {
  thru.common.v1.Signature signature = 1 [(google.api.field_behavior) = REQUIRED];
  thru.common.v1.VersionContext version_context = 2
      [(google.api.field_behavior) = REQUIRED];
  optional thru.common.v1.ConsensusStatus min_consensus = 3
      [(google.api.field_behavior) = OPTIONAL];
}

// GenerateStateProofRequest requests an account state proof.
message GenerateStateProofRequest {
  thru.core.v1.StateProofRequest request = 1
      [(google.api.field_behavior) = REQUIRED];
}

// GenerateStateProofResponse contains the generated proof.
message GenerateStateProofResponse {
  thru.core.v1.StateProof proof = 1 [(google.api.field_behavior) = REQUIRED];
}

// GetBlockRequest retrieves decoded block information by slot or hash.
message GetBlockRequest {
  option (buf.validate.message).cel = {
    id: "block_selector_set"
    message: "either slot or block_hash must be set"
    expression: "has(this.slot) || has(this.block_hash)"
  };

  oneof selector {
    uint64 slot = 1 [(google.api.field_behavior) = OPTIONAL];
    thru.core.v1.BlockHash block_hash = 2 [(google.api.field_behavior) = OPTIONAL];
  }
  optional thru.core.v1.BlockView view = 3 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.ConsensusStatus min_consensus = 4
      [(google.api.field_behavior) = OPTIONAL];
}

// GetRawBlockRequest retrieves raw block bytes by slot or hash.
message GetRawBlockRequest {
  option (buf.validate.message).cel = {
    id: "raw_block_selector_set"
    message: "either slot or block_hash must be set"
    expression: "has(this.slot) || has(this.block_hash)"
  };

  oneof selector {
    uint64 slot = 1 [(google.api.field_behavior) = OPTIONAL];
    thru.core.v1.BlockHash block_hash = 2 [(google.api.field_behavior) = OPTIONAL];
  }
  optional thru.common.v1.ConsensusStatus min_consensus = 3
      [(google.api.field_behavior) = OPTIONAL];
}

// ListAccountsRequest lists accounts using CEL filters.
//
// The filter expression supports filtering on account metadata fields using CEL (Common Expression Language).
// A filter expression is REQUIRED for all ListAccounts requests.
//
// Available fields for filtering:
//   - account.address.value (bytes): The account's public key address
//   - account.meta.owner.value (bytes): The account owner's public key
//   - account.meta.balance (uint64): Account balance in native units
//   - account.meta.seq (uint64): Account sequence number / state counter
//   - account.meta.nonce (uint64): Account transaction nonce
//   - account.meta.data_size (uint32): Size of account data in bytes
//   - account.meta.version (uint32): Account version number
//   - account.meta.flags (AccountFlags): Account capability flags (message type)
//   - account.meta.flags.is_program (bool): Flag indicating if account is a program
//   - account.meta.flags.is_privileged (bool): Flag indicating if account is privileged
//   - account.meta.flags.is_uncompressable (bool): Flag indicating if account data cannot be compressed
//   - account.meta.flags.is_ephemeral (bool): Flag indicating if account is ephemeral
//   - account.meta.flags.is_deleted (bool): Flag indicating if account is deleted
//   - account.meta.flags.is_new (bool): Flag indicating if account is new
//   - account.meta.flags.is_compressed (bool): Flag indicating if account data is compressed
//
// Available CEL functions:
//   - has(field): Check if optional field exists
//   - uint(value): Convert to uint type
//   - int(value): Convert to int type
//   - string(value): Convert to string type
//   - bytes(value): Convert to bytes type
//
// Available filter parameters (accessible via params.* in expressions):
//   - params.owner_bytes (bytes): Owner public key for owner filtering (REQUIRED when filtering by owner)
//   - params.prefix (bytes): Byte prefix for range-based filtering
//   - params.tag (any): Custom tag parameter
//   - params.min_slot (uint64): Minimum slot parameter
//
// Filter examples:
//
// 1. Filter by balance:
//      filter.expression = "account.meta.balance > uint(1000000)"
//
// 2. Filter by balance range:
//      filter.expression = "account.meta.balance >= uint(100) && account.meta.balance <= uint(10000)"
//
// 3. Filter by owner (requires params.owner_bytes):
//      filter.expression = "account.meta.owner.value == params.owner_bytes"
//      filter.params["owner_bytes"].bytes_value = <32-byte owner pubkey>
//
// 4. Filter by data size:
//      filter.expression = "account.meta.data_size > uint(0)"
//      filter.expression = "account.meta.data_size >= uint(100) && account.meta.data_size <= uint(1000)"
//
// 5. Filter by nonce:
//      filter.expression = "account.meta.nonce == uint(0)"
//
// 6. Filter by sequence number:
//      filter.expression = "account.meta.seq >= uint(100)"
//
// 7. Filter by version:
//      filter.expression = "account.meta.version == uint(1)"
//
// 8. Filter by specific address (using inline bytes literal with octal escaping):
//      filter.expression = "account.address.value == b'\001\002\003...'"
//      Note: Binary bytes must be properly escaped using octal notation (\NNN) for non-printable bytes
//
// 9. Filter by address prefix (using range comparison):
//      filter.expression = "account.address.value >= b'\001\002\003\004' && account.address.value <= b'\001\002\003\004\377\377...'"
//      Note: Create upper bound by appending 0xff bytes after prefix
//
// 10. Combine multiple conditions with AND:
//      filter.expression = "account.meta.balance > uint(0) && account.meta.data_size == uint(0)"
//
// 11. Combine multiple conditions with OR:
//      filter.expression = "account.meta.balance == uint(0) || account.meta.balance > uint(50000)"
//
// 12. Complex combined filters:
//      filter.expression = "(account.meta.balance > uint(100) && account.meta.balance < uint(10000)) || account.meta.data_size > uint(1000)"
//
// 13. Check for optional field existence:
//      filter.expression = "has(account.address.value)"
//      filter.expression = "has(account.meta.owner.value)"  // Requires params.owner_bytes
//
// 14. Use inequality operators:
//      filter.expression = "account.meta.balance < uint(5000)"
//      filter.expression = "account.meta.balance <= uint(5000)"
//      filter.expression = "account.meta.balance >= uint(100)"
//      filter.expression = "account.meta.balance != uint(999)"
//
// 15. Type conversions:
//      filter.expression = "account.meta.balance == uint(100)"
//      filter.expression = "uint(account.meta.data_size) > uint(0)"
//
// 16. Filter by account flags (individual flag fields):
//      filter.expression = "account.meta.flags.is_program == true"
//      filter.expression = "account.meta.flags.is_privileged == true"
//      filter.expression = "account.meta.flags.is_uncompressable == true"
//      filter.expression = "account.meta.flags.is_ephemeral == true"
//      filter.expression = "account.meta.flags.is_deleted == true"
//      filter.expression = "account.meta.flags.is_new == true"
//      filter.expression = "account.meta.flags.is_compressed == true"
//
// 17. Combine flag filters with other conditions:
//      filter.expression = "account.meta.flags.is_program == true && account.meta.balance > uint(0)"
//
// Limitations:
//   - The startsWith() function only works with strings, not bytes
//   - The bytesPrefix() function is NOT available for ListAccounts (use range comparison instead)
//   - Parameter names other than owner_bytes, prefix, tag, min_slot are NOT permitted
//   - All filters are pushed down to SQL for optimal performance where possible
message ListAccountsRequest {
  optional thru.core.v1.AccountView view = 1 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.VersionContext version_context = 2
      [(google.api.field_behavior) = OPTIONAL];

  // CEL filter expression (REQUIRED). See message documentation for examples.
  optional thru.common.v1.Filter filter = 3 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.PageRequest page = 4 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.ConsensusStatus min_consensus = 5
      [(google.api.field_behavior) = OPTIONAL];
}

// ListAccountsResponse contains paginated accounts.
message ListAccountsResponse {
  repeated thru.core.v1.Account accounts = 1
      [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.PageResponse page = 2
      [(google.api.field_behavior) = OPTIONAL];
}

// ListBlocksRequest lists blocks with pagination and filtering.
//
// Returns blocks ordered from latest slot to earliest (slot DESC) by default.
// Supports filtering on block header and footer fields using CEL expressions.
//
// Available fields for filtering:
//
// Header fields:
//   - block.header.slot (uint64): Block slot number
//   - block.header.version (uint32): Block version number
//   - block.header.start_slot (uint64): Start slot for block production
//   - block.header.producer.value (bytes): Block producer's public key
//   - block.header.expiry_after (uint32): Expiry duration in slots
//   - block.header.expiry_timestamp (google.protobuf.Timestamp): Expiry timestamp
//   - block.header.max_block_size (uint32): Maximum block size in bytes
//   - block.header.max_compute_units (uint64): Maximum compute units allowed
//   - block.header.max_state_units (uint32): Maximum state units allowed
//   - block.header.bond_amount_lock_up (uint64): Bond amount lock-up for block production
//   - block.header.price (uint64): Block production price
//   - block.header.block_hash.value (bytes): Block hash
//   - block.header.header_signature.value (bytes): Header signature
//   - block.header.block_time (google.protobuf.Timestamp): Block timestamp
//
// Footer fields:
//   - block.footer.signature.value (bytes): Block signature
//   - block.footer.status (int32): Block execution status (2 = EXECUTION_STATUS_EXECUTED)
//   - block.footer.consumed_compute_units (uint64): Total compute units consumed by all transactions
//   - block.footer.consumed_state_units (uint32): Total state units consumed by all transactions
//   - block.footer.attestor_payment (uint64): Payment to attestors for block validation
//
// Consensus status:
//   - block.consensus_status (int32): Consensus status (always CONSENSUS_STATUS_INCLUDED for persisted blocks)
//
// Available CEL functions:
//   - has(field): Check if optional field exists
//   - uint(value): Convert to uint type
//   - int(value): Convert to int type
//   - bytes(value): Convert to bytes type
//   - timestamp(value): Convert to timestamp type
//   - duration(value): Convert to duration type
//
// Available filter parameters (accessible via params.* in expressions):
//   - params.slot (uint64): Slot number for filtering
//   - params.u64 (uint64): Generic uint64 parameter
//   - params.producer (bytes): Producer public key for filtering
//
// Filter examples:
//
// 1. Filter by specific slot:
//      filter.expression = "block.header.slot == uint(1234)"
//
// 2. Filter by slot range:
//      filter.expression = "block.header.slot >= uint(1000) && block.header.slot <= uint(2000)"
//
// 3. Filter by slot using parameter:
//      filter.expression = "block.header.slot == params.slot"
//      filter.params["slot"].uint_value = 1234
//
// 4. Filter by block version:
//      filter.expression = "block.header.version == uint(1)"
//
// 5. Filter by producer (using parameter):
//      filter.expression = "block.header.producer.value == params.producer"
//      filter.params["producer"].bytes_value = <32-byte producer pubkey>
//
// 6. Filter by max compute units:
//      filter.expression = "block.header.max_compute_units > uint(1000000)"
//      filter.expression = "block.header.max_compute_units >= uint(0) && block.header.max_compute_units <= uint(10000000)"
//
// 7. Filter by max state units:
//      filter.expression = "block.header.max_state_units > uint(0)"
//
// 8. Filter by price:
//      filter.expression = "block.header.price >= uint(0)"
//      filter.expression = "block.header.price > uint(1000)"
//
// 9. Filter by start_slot:
//      filter.expression = "block.header.start_slot <= uint(5000)"
//
// 10. Filter by expiry_after:
//      filter.expression = "block.header.expiry_after > uint(0)"
//
// 11. Filter by max_block_size:
//      filter.expression = "block.header.max_block_size >= uint(1000000)"
//
// 12. Filter by execution status:
//      filter.expression = "block.footer.status == int(2)"  // EXECUTION_STATUS_EXECUTED
//
// 13. Filter by consumed compute units:
//      filter.expression = "block.footer.consumed_compute_units > uint(0)"
//      filter.expression = "block.footer.consumed_compute_units >= uint(100) && block.footer.consumed_compute_units <= uint(1000000)"
//
// 14. Filter by consumed state units:
//      filter.expression = "block.footer.consumed_state_units >= uint(0)"
//      filter.expression = "block.footer.consumed_state_units > uint(10)"
//
// 15. Check for footer signature existence:
//      filter.expression = "has(block.footer.signature)"
//
// 16. Check for footer existence:
//      filter.expression = "has(block.footer)"
//
// 17. Check for producer existence:
//      filter.expression = "has(block.header.producer)"
//
// 18. Check for block hash existence:
//      filter.expression = "has(block.header.block_hash)"
//
// 19. Check for header signature existence:
//      filter.expression = "has(block.header.header_signature)"
//
// 20. Check for expiry timestamp existence:
//      filter.expression = "has(block.header.expiry_timestamp)"
//
// 21. Check for block time existence:
//      filter.expression = "has(block.header.block_time)"
//
// 22. Combine multiple header conditions with AND:
//      filter.expression = "block.header.slot >= uint(1000) && block.header.max_compute_units > uint(1000000)"
//
// 23. Combine multiple footer conditions with AND:
//      filter.expression = "block.footer.consumed_compute_units > uint(0) && block.footer.consumed_state_units > uint(0)"
//
// 24. Combine header and footer conditions:
//      filter.expression = "block.header.slot >= uint(1000) && block.footer.consumed_compute_units > uint(100000)"
//
// 25. Combine multiple conditions with OR:
//      filter.expression = "block.header.slot == uint(100) || block.header.slot == uint(200)"
//      filter.expression = "block.footer.consumed_compute_units > uint(1000000) || block.footer.consumed_state_units > uint(10000)"
//
// 26. Complex combined filters:
//      filter.expression = "(block.header.slot >= uint(1000) && block.header.slot <= uint(2000)) || block.footer.consumed_compute_units > uint(5000000)"
//
// 27. Use inequality operators:
//      filter.expression = "block.header.max_compute_units < uint(10000000)"
//      filter.expression = "block.header.max_compute_units <= uint(10000000)"
//      filter.expression = "block.header.price >= uint(100)"
//      filter.expression = "block.footer.consumed_compute_units != uint(0)"
//
// 28. Combine has() with value checks:
//      filter.expression = "has(block.header.producer) && block.header.producer.value == params.producer"
//      filter.params["producer"].bytes_value = <32-byte producer pubkey>
//
// 29. Filter by multiple resource limits:
//      filter.expression = "block.header.max_compute_units > uint(1000000) && block.header.max_state_units > uint(1000) && block.header.max_block_size > uint(1000000)"
//
// 30. Filter blocks with high resource consumption:
//      filter.expression = "block.footer.consumed_compute_units > uint(block.header.max_compute_units / 2)"
//
// Note: All filters are pushed down to SQL for optimal performance where possible.
// When SQL pushdown is not possible, filters are evaluated in-memory on fetched results.
message ListBlocksRequest {
  // CEL filter expression (OPTIONAL). See message documentation for examples.
  optional thru.common.v1.Filter filter = 1 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.PageRequest page = 2 [(google.api.field_behavior) = OPTIONAL];
  optional thru.core.v1.BlockView view = 3 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.ConsensusStatus min_consensus = 4
      [(google.api.field_behavior) = OPTIONAL];
}

// ListBlocksResponse returns a page of blocks.
message ListBlocksResponse {
  repeated thru.core.v1.Block blocks = 1
      [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.PageResponse page = 2
      [(google.api.field_behavior) = OPTIONAL];
}

// ListTransactionsForAccountRequest lists transactions involving a specific account.
//
// This RPC returns all transactions where the specified account appears in any
// capacity (fee payer, signer, or affected account). Results can be filtered
// using CEL expressions on transaction properties.
//
// ## Available Filter Fields
//
// - `transaction.slot` (uint64): Block slot number
// - `transaction.block_offset` (uint32): Position within block
// - `transaction.signature.value` (bytes): Transaction signature
//
// Header fields (in-memory evaluation only, not SQL pushdown):
// - `transaction.header.version` (uint32): Transaction format version
// - `transaction.header.fee` (uint64): Transaction fee
// - `transaction.header.nonce` (uint64): Sender account nonce
// - `transaction.header.start_slot` (uint64): Earliest slot for execution
// - `transaction.header.expiry_after` (uint32): Expiry duration in slots
// - `transaction.header.requested_compute_units` (uint64): Requested compute units
// - `transaction.header.requested_memory_units` (uint32): Requested memory units
// - `transaction.header.requested_state_units` (uint32): Requested state units
// - `transaction.header.fee_payer_pubkey.value` (bytes): Fee payer public key
// - `transaction.header.program_pubkey.value` (bytes): Program public key
// - `transaction.header.fee_payer_signature.value` (bytes): Fee payer signature
//
// Execution result fields:
// - `transaction.execution_result.vm_error` (TransactionVmError enum): VM execution status (0 = success)
// - `transaction.execution_result.user_error_code` (uint64): User-defined error code
// - `transaction.execution_result.execution_result` (uint64): Alias for user_error_code
// - `transaction.execution_result.consumed_compute_units` (uint64): Compute units used
// - `transaction.execution_result.consumed_memory_units` (uint32): Memory units used
// - `transaction.execution_result.consumed_state_units` (uint32): State units used
// - `transaction.execution_result.events_count` (uint32): Number of events emitted
// - `transaction.execution_result.events_size` (uint32): Total size of event data in bytes
//
// ## Filter Examples
//
// ### Filter by slot
// ```
// filter {
//   expression: "transaction.slot == params.slot"
//   params {
//     key: "slot"
//     value { int_value: 12345 }
//   }
// }
// ```
//
// ### Filter by block offset
// ```
// filter {
//   expression: "transaction.block_offset == uint(5)"
// }
// ```
//
// ### Filter by compute units (high usage)
// ```
// filter {
//   expression: "transaction.execution_result.consumed_compute_units >= uint(1000000)"
// }
// ```
//
// ### Filter by memory units
// ```
// filter {
//   expression: "transaction.execution_result.consumed_memory_units > uint(0)"
// }
// ```
//
// ### Filter by state units
// ```
// filter {
//   expression: "transaction.execution_result.consumed_state_units > uint(0)"
// }
// ```
//
// ### Filter successful transactions (by error code)
// ```
// filter {
//   expression: "transaction.execution_result.user_error_code == uint(0)"
// }
// ```
//
// ### Filter by VM execution status
// ```
// filter {
//   expression: "transaction.execution_result.vm_error == int(0)"
// }
// ```
//
// ### Filter transactions with events
// ```
// filter {
//   expression: "transaction.execution_result.events_count > uint(0)"
// }
// ```
//
// ### Filter by event data size
// ```
// filter {
//   expression: "transaction.execution_result.events_size > uint(0)"
// }
// ```
//
// ### Check for optional fields using has()
// ```
// filter {
//   expression: "has(transaction.execution_result)"
// }
// ```
//
// ### Combined filters with AND/OR
// ```
// filter {
//   expression: "transaction.execution_result.consumed_compute_units >= uint(1000000) && transaction.execution_result.user_error_code == uint(0)"
// }
// ```
//
// ### Using params for dynamic values
// ```
// filter {
//   expression: "transaction.execution_result.consumed_compute_units >= params.u64"
//   params {
//     key: "u64"
//     value { int_value: 500000 }
//   }
// }
// ```
//
// ## Available Functions
//
// - `has(field)`: Check if optional field is present
// - `uint(value)`: Convert to unsigned integer
// - `int(value)`: Convert to signed integer
// - `string(value)`: Convert to string type
// - `bytes(value)`: Convert to bytes type
//
// ## Available Filter Parameters
//
// - `params.slot` (uint64): Slot number for filtering
// - `params.u64` (uint64): Generic uint64 parameter
// - `params.pubkey` (Pubkey): Public key parameter for filtering
//
// ## Performance Notes
//
// Filters on `transaction.slot`, `transaction.block_offset`, and
// `transaction.execution_result.*` fields are optimized with SQL pushdown
// for better performance. Complex expressions may fall back to in-memory evaluation.
message ListTransactionsForAccountRequest {
  thru.common.v1.Pubkey account = 1 [(google.api.field_behavior) = REQUIRED];
  optional thru.common.v1.PageRequest page = 2 [(google.api.field_behavior) = OPTIONAL];
  // Optional CEL filter applied after the account constraint.
  optional thru.common.v1.Filter filter = 3 [(google.api.field_behavior) = OPTIONAL];
}

// ListTransactionsForAccountResponse contains transaction data.
//
message ListTransactionsForAccountResponse {
  optional thru.common.v1.PageResponse page = 1
      [(google.api.field_behavior) = OPTIONAL];
  repeated thru.core.v1.Transaction transactions = 2
      [(google.api.field_behavior) = OPTIONAL];
}

// GetVersionRequest fetches component version strings.
message GetVersionRequest {}

// GetVersionResponse returns version information per component.
message GetVersionResponse {
  map<string, string> versions = 1
      [(google.api.field_behavior) = REQUIRED];
}

// GetEventRequest fetches an event by identifier.
message GetEventRequest {
  string event_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.max_len = 128
  ];
  optional thru.common.v1.VersionContext version_context = 2
      [(google.api.field_behavior) = OPTIONAL];
}

// Event represents a transaction event emitted by the chain.
message Event {
  string event_id = 1 [(google.api.field_behavior) = REQUIRED];
  thru.common.v1.Signature transaction_signature = 2
      [(google.api.field_behavior) = REQUIRED];
  optional thru.common.v1.Pubkey program = 3 [(google.api.field_behavior) = OPTIONAL];
  optional bytes payload = 4 [(google.api.field_behavior) = OPTIONAL];
  optional uint64 slot = 5 [(google.api.field_behavior) = OPTIONAL];
  optional uint32 call_idx = 6 [(google.api.field_behavior) = OPTIONAL];
  optional uint32 program_idx = 7 [(google.api.field_behavior) = OPTIONAL];
  optional uint32 payload_size = 8 [(google.api.field_behavior) = OPTIONAL];
  optional uint32 block_offset = 9 [(google.api.field_behavior) = OPTIONAL];
  optional google.protobuf.Timestamp timestamp = 10 [(google.api.field_behavior) = OPTIONAL];
}

// ListEventsRequest lists events with CEL filtering and pagination.
//
// Returns events ordered from most recent to older (slot DESC, block_offset DESC, call_idx DESC).
// Supports filtering on event metadata and payload using CEL expressions with specialized byte functions.
//
// Available fields for filtering:
//   - event.event_id (string): Unique event identifier (format: "ts{slot}_{block_offset}_{call_idx}")
//   - event.transaction_signature.value (bytes): Transaction signature that emitted the event
//   - event.slot (uint64): Block slot number where event was emitted
//   - event.call_idx (uint32): Instruction call index within transaction
//   - event.block_offset (uint32): Transaction's position within the block
//   - event.timestamp (google.protobuf.Timestamp): Event emission timestamp
//   - event.program.value (bytes): Program public key that emitted the event
//   - event.program_idx (uint32): Program index within transaction
//   - event.payload (bytes): Event payload data
//   - event.payload_size (uint32): Size of event payload in bytes
//
// Available CEL functions:
//   - has(field): Check if optional field exists
//   - startsWith(string, prefix): Check if string starts with prefix (string fields only)
//   - first1Byte(bytes): Extract first byte as uint8
//   - first4Bytes(bytes): Extract first 4 bytes as uint32 (little-endian)
//   - first8Bytes(bytes): Extract first 8 bytes as uint64 (little-endian)
//   - bytesPrefix(bytes, prefix): Check if bytes start with prefix
//   - uint(value): Convert to uint type
//   - int(value): Convert to int type
//   - string(value): Convert to string type
//   - bytes(value): Convert to bytes type
//   - double(value): Convert to double type
//   - timestamp(value): Convert to timestamp type
//   - duration(value): Convert to duration type
//
// Available filter parameters (accessible via params.* in expressions):
//   - params.slot (uint64): Slot number for filtering
//   - params.u64 (uint64): Generic uint64 parameter for payload matching
//   - params.signature (Signature): Transaction signature for filtering
//   - params.signature.value (bytes): Transaction signature bytes for filtering
//   - params.address (Pubkey): Program address for filtering
//   - params.address.value (bytes): Program address bytes for filtering
//   - params.prefix (bytes): Byte prefix for payload filtering
//   - params.timestamp (Timestamp): Timestamp parameter for filtering
//
// Filter examples:
//
// 1. Filter by slot:
//      filter.expression = "event.slot > uint(1000)"
//      filter.expression = "event.slot >= uint(100) && event.slot <= uint(200)"
//
// 2. Filter by slot using parameter:
//      filter.expression = "event.slot >= params.slot"
//      filter.params["slot"].int_value = 1234
//
// 3. Filter by call index:
//      filter.expression = "event.call_idx == uint(0)"  // First instruction
//      filter.expression = "event.call_idx > uint(0)"   // Nested instructions
//
// 4. Filter by block offset:
//      filter.expression = "event.block_offset >= uint(0)"
//      filter.expression = "event.block_offset == uint(5)"
//
// 5. Filter by transaction signature (using parameter):
//      filter.expression = "event.transaction_signature.value == params.signature"
//      filter.params["signature"].signature_value.value = <64-byte signature>
//
// 6. Filter by program address (using parameter):
//      filter.expression = "has(event.program) && event.program.value == params.address"
//      filter.params["address"].pubkey_value.value = <32-byte program pubkey>
//
// 7. Filter by event ID prefix using startsWith:
//      filter.expression = "event.event_id.startsWith(\"ts\")"
//      filter.expression = "event.event_id.startsWith(\"ts1000_\")"
//
// 8. Check for payload existence:
//      filter.expression = "has(event.payload)"
//
// 9. Check for program existence:
//      filter.expression = "has(event.program)"
//
// 10. Filter by payload first byte (event type):
//      filter.expression = "has(event.payload) && first1Byte(event.payload) == uint(1)"  // MESSAGE events
//      filter.expression = "has(event.payload) && first1Byte(event.payload) == uint(2)"  // Other type
//
// 11. Filter by payload first 4 bytes (uint32 event type):
//      filter.expression = "has(event.payload) && first4Bytes(event.payload) == uint(2)"  // COUNTER events
//      filter.expression = "has(event.payload) && first4Bytes(event.payload) == params.u64"
//      filter.params["u64"].int_value = 2
//
// 12. Filter by payload first 8 bytes (uint64 event type):
//      filter.expression = "has(event.payload) && first8Bytes(event.payload) == uint(6)"  // PATTERN events
//      filter.expression = "has(event.payload) && first8Bytes(event.payload) == params.u64"
//      filter.params["u64"].int_value = 6
//
// 13. Filter by payload byte prefix:
//      filter.expression = "bytesPrefix(event.payload, params.prefix)"
//      filter.params["prefix"].bytes_value = <byte prefix to match>
//
// 14. Combine slot and call_idx filters:
//      filter.expression = "event.slot > uint(1000) && event.call_idx == uint(0)"
//
// 15. Combine slot, call_idx, and payload existence:
//      filter.expression = "event.slot > uint(1000) && event.call_idx == uint(0) && has(event.payload)"
//
// 16. Filter by program and payload type:
//      filter.expression = "has(event.program) && event.program.value == params.address && first1Byte(event.payload) == uint(1)"
//      filter.params["address"].pubkey_value.value = <32-byte program pubkey>
//
// 17. Filter MESSAGE events (type 1) with specific program:
//      filter.expression = "has(event.payload) && first1Byte(event.payload) == uint(1) && event.program.value == params.address"
//      filter.params["address"].pubkey_value.value = <32-byte program pubkey>
//
// 18. Filter COUNTER events (type 2) in slot range:
//      filter.expression = "has(event.payload) && first4Bytes(event.payload) == uint(2) && event.slot >= uint(100) && event.slot <= uint(200)"
//
// 19. Filter PATTERN events (type 6) with payload prefix:
//      filter.expression = "has(event.payload) && first8Bytes(event.payload) == uint(6) && bytesPrefix(event.payload, params.prefix)"
//      filter.params["prefix"].bytes_value = <pattern prefix bytes>
//
// 20. Complex combined filter:
//      filter.expression = "(event.slot > uint(1000) && event.call_idx == uint(0)) || first1Byte(event.payload) == uint(1)"
//
// 21. Filter events from specific transaction:
//      filter.expression = "event.transaction_signature.value == params.signature && has(event.payload)"
//      filter.params["signature"].signature_value.value = <64-byte signature>
//
// 22. Filter by multiple payload type options:
//      filter.expression = "has(event.payload) && (first1Byte(event.payload) == uint(1) || first1Byte(event.payload) == uint(2))"
//
// 23. Filter nested instruction events:
//      filter.expression = "event.call_idx > uint(0) && has(event.program)"
//
// 24. Filter first instruction events only:
//      filter.expression = "event.call_idx == uint(0)"
//
// 25. Filter events with payload longer than specific size (using bytesPrefix with empty prefix):
//      filter.expression = "has(event.payload)"
//
// 26. Combine has() checks:
//      filter.expression = "has(event.program) && has(event.payload) && has(event.timestamp)"
//
// 27. Use inequality operators:
//      filter.expression = "event.slot < uint(10000)"
//      filter.expression = "event.slot <= uint(10000)"
//      filter.expression = "event.call_idx >= uint(0)"
//      filter.expression = "event.block_offset != uint(0)"
//
// 28. Filter by timestamp (if available):
//      filter.expression = "has(event.timestamp)"
//
// 29. Match specific event ID pattern:
//      filter.expression = "event.event_id.startsWith(\"ts1234_0_\")"
//
// 30. Complex payload and metadata filter:
//      filter.expression = "event.slot >= params.slot && has(event.payload) && first8Bytes(event.payload) == params.u64 && event.program.value == params.address"
//      filter.params["slot"].int_value = 1000
//      filter.params["u64"].int_value = 6
//      filter.params["address"].pubkey_value.value = <32-byte program pubkey>
//
// Note: Filters on slot, call_idx, block_offset, transaction_signature, and program are pushed down to SQL
// for optimal performance. Payload filters (first1Byte, first4Bytes, first8Bytes, bytesPrefix) are evaluated
// in-memory on fetched results.
message ListEventsRequest {
  // CEL filter expression (OPTIONAL). See message documentation for examples.
  optional thru.common.v1.Filter filter = 1 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.PageRequest page = 2 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.VersionContext version_context = 3
      [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.ConsensusStatus min_consensus = 4
      [(google.api.field_behavior) = OPTIONAL];
}

// ListEventsResponse returns paginated events.
message ListEventsResponse {
  repeated Event events = 1 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.PageResponse page = 2 [(google.api.field_behavior) = OPTIONAL];
}

// ListTransactionsRequest lists executed transactions with CEL filtering and pagination.
//
// Returns transactions ordered from most recent to older (slot DESC, block_offset DESC).
// Supports filtering on transaction metadata and execution results using CEL expressions.
//
// Available fields for filtering:
//   - transaction.slot (uint64): Block slot number where transaction was executed
//   - transaction.block_offset (uint32): Transaction's position within the block
//   - transaction.signature.value (bytes): Transaction signature
//
// Header fields (in-memory evaluation only, not SQL pushdown):
//   - transaction.header.version (uint32): Transaction format version
//   - transaction.header.fee (uint64): Transaction fee
//   - transaction.header.nonce (uint64): Sender account nonce
//   - transaction.header.start_slot (uint64): Earliest slot for execution
//   - transaction.header.expiry_after (uint32): Expiry duration in slots
//   - transaction.header.requested_compute_units (uint64): Requested compute units
//   - transaction.header.requested_memory_units (uint32): Requested memory units
//   - transaction.header.requested_state_units (uint32): Requested state units
//   - transaction.header.fee_payer_pubkey.value (bytes): Fee payer public key
//   - transaction.header.program_pubkey.value (bytes): Program public key
//   - transaction.header.fee_payer_signature.value (bytes): Fee payer signature
//
// Execution result fields:
//   - transaction.execution_result.vm_error (TransactionVmError enum): VM error code (0 = success)
//   - transaction.execution_result.user_error_code (uint64): User-defined error code
//   - transaction.execution_result.execution_result (uint64): Alias for user_error_code
//   - transaction.execution_result.consumed_compute_units (uint64): Compute units consumed
//   - transaction.execution_result.consumed_memory_units (uint32): Memory units consumed
//   - transaction.execution_result.consumed_state_units (uint32): State units consumed
//   - transaction.execution_result.events_count (uint32): Number of events emitted
//   - transaction.execution_result.events_size (uint32): Total size of events in bytes
//
// Available CEL functions:
//   - has(field): Check if optional field exists
//   - uint(value): Convert to uint type
//   - int(value): Convert to int type
//   - string(value): Convert to string type
//   - bytes(value): Convert to bytes type
//
// Available filter parameters (accessible via params.* in expressions):
//   - params.slot (uint64): Slot number for filtering
//   - params.u64 (uint64): Generic uint64 parameter
//   - params.pubkey (Pubkey): Public key parameter for filtering
//
// Filter examples:
//
// 1. Filter by slot range:
//      filter.expression = "transaction.slot >= uint(1000) && transaction.slot <= uint(2000)"
//
// 2. Filter by successful transactions (no error):
//      filter.expression = "transaction.execution_result.user_error_code == uint(0)"
//      filter.expression = "transaction.execution_result.vm_error == int(0)"
//
// 3. Filter by specific VM error:
//      filter.expression = "transaction.execution_result.vm_error == int(2)"  // VM_REVERT
//      filter.expression = "transaction.execution_result.vm_error == int(4)"  // NONCE_TOO_LOW
//      filter.expression = "transaction.execution_result.vm_error == int(5)"  // NONCE_TOO_HIGH
//
// 4. Filter by resource usage:
//      filter.expression = "transaction.execution_result.consumed_compute_units > uint(1000)"
//      filter.expression = "transaction.execution_result.consumed_memory_units > uint(0)"
//      filter.expression = "transaction.execution_result.consumed_state_units >= uint(0)"
//
// 5. Filter by compute units range:
//      filter.expression = "transaction.execution_result.consumed_compute_units >= uint(0) && transaction.execution_result.consumed_compute_units < uint(1000000)"
//
// 6. Filter by events count:
//      filter.expression = "transaction.execution_result.events_count == uint(0)"  // No events (transfers)
//      filter.expression = "transaction.execution_result.events_count > uint(0)"   // Has events
//      filter.expression = "transaction.execution_result.events_count == uint(1)"  // Exactly 1 event
//
// 7. Filter by events size:
//      filter.expression = "transaction.execution_result.events_size == uint(0)"  // No events
//      filter.expression = "transaction.execution_result.events_size > uint(0)"   // Has events
//      filter.expression = "transaction.execution_result.events_size >= uint(100)" // Large events
//      filter.expression = "transaction.execution_result.events_size >= uint(50) && transaction.execution_result.events_size <= uint(200)"
//
// 8. Filter by block offset:
//      filter.expression = "transaction.block_offset >= uint(0)"
//      filter.expression = "transaction.block_offset == uint(5)"
//
// 9. Combine multiple conditions with AND:
//      filter.expression = "transaction.execution_result.user_error_code == uint(0) && transaction.execution_result.consumed_compute_units > uint(0)"
//
// 10. Combine multiple conditions with OR:
//      filter.expression = "transaction.execution_result.user_error_code == uint(0) || transaction.execution_result.user_error_code != uint(0)"
//      filter.expression = "transaction.execution_result.vm_error == int(2) || transaction.execution_result.vm_error == int(4)"
//
// 11. Complex combined filters:
//      filter.expression = "(transaction.slot >= uint(0) && transaction.execution_result.user_error_code == uint(0)) || transaction.execution_result.consumed_compute_units > uint(100000)"
//
// 12. Check for field existence:
//      filter.expression = "has(transaction.execution_result)"
//
// 13. Use inequality operators:
//      filter.expression = "transaction.execution_result.consumed_compute_units < uint(1000000)"
//      filter.expression = "transaction.execution_result.consumed_compute_units <= uint(1000000)"
//      filter.expression = "transaction.execution_result.consumed_compute_units >= uint(0)"
//      filter.expression = "transaction.execution_result.user_error_code != uint(999)"
//
// 14. Use params.slot parameter:
//      filter.expression = "transaction.slot == params.slot"
//      filter.params["slot"].uint_value = 1234
//
// 15. Use params.u64 with type conversion:
//      filter.expression = "transaction.execution_result.consumed_compute_units < uint(params.u64)"
//      filter.params["u64"].uint_value = 1000000
//
// The return_events flag controls whether event data is included in the response:
//   - return_events = false (default): Only event counts/sizes are returned, not actual event data
//   - return_events = true: Full event data is included in execution results
//
// Note: All filters are pushed down to SQL for optimal performance where possible.
message ListTransactionsRequest {
  // CEL filter expression (OPTIONAL). See message documentation for examples.
  optional thru.common.v1.Filter filter = 1 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.PageRequest page = 2 [(google.api.field_behavior) = OPTIONAL];
  // Whether to include event data in results (default: false)
  optional bool return_events = 3 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.VersionContext version_context = 4
      [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.ConsensusStatus min_consensus = 5
      [(google.api.field_behavior) = OPTIONAL];
}

// ListTransactionsResponse returns paginated executed transactions.
message ListTransactionsResponse {
  repeated thru.core.v1.Transaction transactions = 1 [(google.api.field_behavior) = OPTIONAL];
  optional thru.common.v1.PageResponse page = 2 [(google.api.field_behavior) = OPTIONAL];
}

// GetTransactionStatusRequest fetches execution status for a transaction.
message GetTransactionStatusRequest {
  thru.common.v1.Signature signature = 1 [(google.api.field_behavior) = REQUIRED];
}

// TransactionStatus captures status metadata for a transaction.
message TransactionStatus {
  thru.common.v1.Signature signature = 1 [(google.api.field_behavior) = REQUIRED];
  optional thru.common.v1.ConsensusStatus consensus_status = 2
      [(google.api.field_behavior) = OPTIONAL];
  optional thru.core.v1.TransactionExecutionResult execution_result = 3
      [(google.api.field_behavior) = OPTIONAL];
}

//
message GetHeightRequest {}

// GetHeightResponse
message GetHeightResponse {
  uint64 finalized = 1 [(google.api.field_behavior) = REQUIRED];
  uint64 locally_executed = 2 [(google.api.field_behavior) = REQUIRED];
  uint64 cluster_executed = 3 [(google.api.field_behavior) = REQUIRED];
}

// GetStateRootsRequest retrieves up to 257 state roots ending at a specified slot.
// Used for transaction replay to verify state proofs against historical roots.
// Returns state roots in ascending slot order, from (slot - 256) to slot (inclusive).
message GetStateRootsRequest {
  // The slot to retrieve state roots up to (inclusive).
  // Returns up to 257 state roots ending at this slot.
  // If not specified, returns state roots ending at the latest available slot.
  optional uint64 slot = 1 [(google.api.field_behavior) = OPTIONAL];
}

// StateRootEntry represents a state root for a specific slot.
message StateRootEntry {
  uint64 slot = 1 [(google.api.field_behavior) = REQUIRED];
  bytes state_root = 2 [(google.api.field_behavior) = REQUIRED];
}

// GetStateRootsResponse contains up to 257 state roots ending at the requested slot.
message GetStateRootsResponse {
  repeated StateRootEntry state_roots = 1 [(google.api.field_behavior) = REQUIRED];
}


// QueryService defines unary RPCs for accessing blockchain data.
service QueryService {
  option (google.api.default_host) = "api.thru.network";

  // Get block heights
  rpc GetHeight(GetHeightRequest) returns (GetHeightResponse) {
    option (google.api.http) = {
      get: "/v1/height"
    };
  }

  // Get account information.
  rpc GetAccount(GetAccountRequest) returns (thru.core.v1.Account) {
    option (google.api.http) = {
      get: "/v1/accounts/{address.value}"
    };
    option (google.api.method_signature) = "address";
  }

  // Get account raw bytes.
  rpc GetRawAccount(GetRawAccountRequest) returns (thru.core.v1.RawAccount) {
    option (google.api.http) = {
      get: "/v1/accounts/{address.value}:raw"
    };
    option (google.api.method_signature) = "address";
  }

  // Get transaction by signature.
  rpc GetTransaction(GetTransactionRequest) returns (thru.core.v1.Transaction) {
    option (google.api.http) = {
      get: "/v1/transactions/{signature.value}"
    };
    option (google.api.method_signature) = "signature";
  }

  // Get raw transaction by signature.
  rpc GetRawTransaction(GetRawTransactionRequest)
      returns (thru.core.v1.RawTransaction) {
    option (google.api.http) = {
      get: "/v1/transactions/{signature.value}:raw"
    };
    option (google.api.method_signature) = "signature";
  }

  // Get block by slot or hash.
  rpc GetBlock(GetBlockRequest) returns (thru.core.v1.Block) {
    option (google.api.http) = {
      get: "/v1/blocks/{slot}"
      additional_bindings {
        get: "/v1/blocks/by-hash/{block_hash.value}"
      }
    };
  }

  // Get raw block bytes.
  rpc GetRawBlock(GetRawBlockRequest) returns (thru.core.v1.RawBlock) {
    option (google.api.http) = {
      get: "/v1/blocks/{slot}:raw"
      additional_bindings {
        get: "/v1/blocks/by-hash/{block_hash.value}:raw"
      }
    };
  }

  // List accounts using CEL-based filtering.
  rpc ListAccounts(ListAccountsRequest) returns (ListAccountsResponse) {
    option (google.api.http) = {
      get: "/v1/accounts"
    };
  }

  // List blocks using pagination and filtering. By default returns blocks ordered from latest slot to the first one.
  rpc ListBlocks(ListBlocksRequest) returns (ListBlocksResponse) {
    option (google.api.http) = {
      get: "/v1/blocks"
    };
  }

  // List executed transaction signatures involving an account.
  rpc ListTransactionsForAccount(ListTransactionsForAccountRequest)
      returns (ListTransactionsForAccountResponse) {
    option (google.api.http) = {
      get: "/v1/accounts/{account.value}/transactions"
    };
    option (google.api.method_signature) = "account";
  }

  // Get a specific event by ID.
  rpc GetEvent(GetEventRequest) returns (Event) {
    option (google.api.http) = {
      get: "/v1/events/{event_id}"
    };
    option (google.api.method_signature) = "event_id";
  }

  // List events with CEL filtering and pagination. Returns events ordered from most recent to older.
  rpc ListEvents(ListEventsRequest) returns (ListEventsResponse) {
    option (google.api.http) = {
      get: "/v1/events"
    };
  }

  // List executed transactions with CEL filtering and pagination. Returns transactions ordered from most recent to older.
  rpc ListTransactions(ListTransactionsRequest) returns (ListTransactionsResponse) {
    option (google.api.http) = {
      get: "/v1/transactions"
    };
  }

  // Get derived transaction status metadata.
  rpc GetTransactionStatus(GetTransactionStatusRequest)
      returns (TransactionStatus) {
    option (google.api.http) = {
      get: "/v1/transactions/{signature.value}:status"
    };
    option (google.api.method_signature) = "signature";
  }

  // Generate an account state proof snapshot.
  rpc GenerateStateProof(GenerateStateProofRequest)
      returns (GenerateStateProofResponse) {
    option (google.api.http) = {
      post: "/v1/stateproofs:generate"
      body: "*"
    };
  }

  // Get component version strings.
  rpc GetVersion(GetVersionRequest) returns (GetVersionResponse) {
    option (google.api.http) = {
      get: "/v1/version"
    };
  }

  // Get state roots for a range of slots.
  // Used for transaction replay to verify state proofs against historical roots.
  rpc GetStateRoots(GetStateRootsRequest) returns (GetStateRootsResponse) {
    option (google.api.http) = {
      get: "/v1/stateroots"
    };
  }
}
