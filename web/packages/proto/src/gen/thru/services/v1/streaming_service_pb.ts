// @generated by protoc-gen-es v2.10.1 with parameter "target=ts"
// @generated from file thru/services/v1/streaming_service.proto (package thru.services.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_buf_validate_validate } from "../../../buf/validate/validate_pb";
import { file_google_api_field_behavior } from "../../../google/api/field_behavior_pb";
import type { Pubkey, Signature } from "../../common/v1/primitives_pb";
import { file_thru_common_v1_primitives } from "../../common/v1/primitives_pb";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { ConsensusStatus } from "../../common/v1/consensus_pb";
import { file_thru_common_v1_consensus } from "../../common/v1/consensus_pb";
import type { Filter } from "../../common/v1/filters_pb";
import { file_thru_common_v1_filters } from "../../common/v1/filters_pb";
import type { Account, AccountMeta, AccountPage, AccountView } from "../../core/v1/account_pb";
import { file_thru_core_v1_account } from "../../core/v1/account_pb";
import type { Block, BlockView } from "../../core/v1/block_pb";
import { file_thru_core_v1_block } from "../../core/v1/block_pb";
import type { Transaction, TransactionExecutionResult } from "../../core/v1/transaction_pb";
import { file_thru_core_v1_transaction } from "../../core/v1/transaction_pb";
import { file_thru_core_v1_types } from "../../core/v1/types_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file thru/services/v1/streaming_service.proto.
 */
export const file_thru_services_v1_streaming_service: GenFile = /*@__PURE__*/
  fileDesc("Cih0aHJ1L3NlcnZpY2VzL3YxL3N0cmVhbWluZ19zZXJ2aWNlLnByb3RvEhB0aHJ1LnNlcnZpY2VzLnYxIo0CChNTdHJlYW1CbG9ja3NSZXF1ZXN0EhwKCnN0YXJ0X3Nsb3QYASABKARCA+BBAUgAiAEBEjAKBmZpbHRlchgCIAEoCzIWLnRocnUuY29tbW9uLnYxLkZpbHRlckID4EEBSAGIAQESLwoEdmlldxgDIAEoDjIXLnRocnUuY29yZS52MS5CbG9ja1ZpZXdCA+BBAUgCiAEBEkAKDW1pbl9jb25zZW5zdXMYBCABKA4yHy50aHJ1LmNvbW1vbi52MS5Db25zZW5zdXNTdGF0dXNCA+BBAUgDiAEBQg0KC19zdGFydF9zbG90QgkKB19maWx0ZXJCBwoFX3ZpZXdCEAoOX21pbl9jb25zZW5zdXMiPwoUU3RyZWFtQmxvY2tzUmVzcG9uc2USJwoFYmxvY2sYASABKAsyEy50aHJ1LmNvcmUudjEuQmxvY2tCA+BBAiKcAQobU3RyZWFtQWNjb3VudFVwZGF0ZXNSZXF1ZXN0EjEKBHZpZXcYAiABKA4yGS50aHJ1LmNvcmUudjEuQWNjb3VudFZpZXdCA+BBAUgAiAEBEjAKBmZpbHRlchgEIAEoCzIWLnRocnUuY29tbW9uLnYxLkZpbHRlckID4EEBSAGIAQFCBwoFX3ZpZXdCCQoHX2ZpbHRlckoECAEQAiLtAQoNQWNjb3VudFVwZGF0ZRIRCgRzbG90GAEgASgEQgPgQQISMQoEcGFnZRgCIAEoCzIZLnRocnUuY29yZS52MS5BY2NvdW50UGFnZUID4EEBSACIAQESMQoEbWV0YRgDIAEoCzIZLnRocnUuY29yZS52MS5BY2NvdW50TWV0YUID4EEBSAGIAQESGAoGZGVsZXRlGAQgASgIQgPgQQFIAogBARIsCgdhZGRyZXNzGAUgASgLMhYudGhydS5jb21tb24udjEuUHVia2V5QgPgQQJCBwoFX3BhZ2VCBwoFX21ldGFCCQoHX2RlbGV0ZSIiCg1CbG9ja0ZpbmlzaGVkEhEKBHNsb3QYASABKARCA+BBAiK8AQocU3RyZWFtQWNjb3VudFVwZGF0ZXNSZXNwb25zZRIpCghzbmFwc2hvdBgBIAEoCzIVLnRocnUuY29yZS52MS5BY2NvdW50SAASMQoGdXBkYXRlGAIgASgLMh8udGhydS5zZXJ2aWNlcy52MS5BY2NvdW50VXBkYXRlSAASMwoIZmluaXNoZWQYAyABKAsyHy50aHJ1LnNlcnZpY2VzLnYxLkJsb2NrRmluaXNoZWRIAEIJCgdtZXNzYWdlIqwBChlTdHJlYW1UcmFuc2FjdGlvbnNSZXF1ZXN0EjAKBmZpbHRlchgBIAEoCzIWLnRocnUuY29tbW9uLnYxLkZpbHRlckID4EEBSACIAQESQAoNbWluX2NvbnNlbnN1cxgCIAEoDjIfLnRocnUuY29tbW9uLnYxLkNvbnNlbnN1c1N0YXR1c0ID4EEBSAGIAQFCCQoHX2ZpbHRlckIQCg5fbWluX2NvbnNlbnN1cyJRChpTdHJlYW1UcmFuc2FjdGlvbnNSZXNwb25zZRIzCgt0cmFuc2FjdGlvbhgBIAEoCzIZLnRocnUuY29yZS52MS5UcmFuc2FjdGlvbkID4EECIlIKE1N0cmVhbUV2ZW50c1JlcXVlc3QSMAoGZmlsdGVyGAEgASgLMhYudGhydS5jb21tb24udjEuRmlsdGVyQgPgQQFIAIgBAUIJCgdfZmlsdGVyIqYCChRTdHJlYW1FdmVudHNSZXNwb25zZRIVCghldmVudF9pZBgBIAEoCUID4EECEhkKB3BheWxvYWQYAiABKAxCA+BBAUgAiAEBEjcKCXRpbWVzdGFtcBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAUgBiAEBEiwKB3Byb2dyYW0YBCABKAsyFi50aHJ1LmNvbW1vbi52MS5QdWJrZXlCA+BBAhIVCghjYWxsX2lkeBgFIAEoDUID4EECEjEKCXNpZ25hdHVyZRgGIAEoCzIZLnRocnUuY29tbW9uLnYxLlNpZ25hdHVyZUID4EECEhEKBHNsb3QYByABKARCA+BBAkIKCghfcGF5bG9hZEIMCgpfdGltZXN0YW1wIo4BChdUcmFja1RyYW5zYWN0aW9uUmVxdWVzdBIxCglzaWduYXR1cmUYASABKAsyGS50aHJ1LmNvbW1vbi52MS5TaWduYXR1cmVCA+BBAhI0Cgd0aW1lb3V0GAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgPgQQFIAIgBAUIKCghfdGltZW91dCLWAQoYVHJhY2tUcmFuc2FjdGlvblJlc3BvbnNlEjEKCXNpZ25hdHVyZRgBIAEoCzIZLnRocnUuY29tbW9uLnYxLlNpZ25hdHVyZUID4EECEj4KEGNvbnNlbnN1c19zdGF0dXMYAiABKA4yHy50aHJ1LmNvbW1vbi52MS5Db25zZW5zdXNTdGF0dXNCA+BBARJHChBleGVjdXRpb25fcmVzdWx0GAMgASgLMigudGhydS5jb3JlLnYxLlRyYW5zYWN0aW9uRXhlY3V0aW9uUmVzdWx0QgPgQQEiFQoTU3RyZWFtSGVpZ2h0UmVxdWVzdCJsChRTdHJlYW1IZWlnaHRSZXNwb25zZRIWCglmaW5hbGl6ZWQYASABKARCA+BBAhIdChBsb2NhbGx5X2V4ZWN1dGVkGAIgASgEQgPgQQISHQoQY2x1c3Rlcl9leGVjdXRlZBgDIAEoBEID4EECMo4FChBTdHJlYW1pbmdTZXJ2aWNlEl8KDFN0cmVhbUJsb2NrcxIlLnRocnUuc2VydmljZXMudjEuU3RyZWFtQmxvY2tzUmVxdWVzdBomLnRocnUuc2VydmljZXMudjEuU3RyZWFtQmxvY2tzUmVzcG9uc2UwARJ3ChRTdHJlYW1BY2NvdW50VXBkYXRlcxItLnRocnUuc2VydmljZXMudjEuU3RyZWFtQWNjb3VudFVwZGF0ZXNSZXF1ZXN0Gi4udGhydS5zZXJ2aWNlcy52MS5TdHJlYW1BY2NvdW50VXBkYXRlc1Jlc3BvbnNlMAEScQoSU3RyZWFtVHJhbnNhY3Rpb25zEisudGhydS5zZXJ2aWNlcy52MS5TdHJlYW1UcmFuc2FjdGlvbnNSZXF1ZXN0GiwudGhydS5zZXJ2aWNlcy52MS5TdHJlYW1UcmFuc2FjdGlvbnNSZXNwb25zZTABEl8KDFN0cmVhbUV2ZW50cxIlLnRocnUuc2VydmljZXMudjEuU3RyZWFtRXZlbnRzUmVxdWVzdBomLnRocnUuc2VydmljZXMudjEuU3RyZWFtRXZlbnRzUmVzcG9uc2UwARJrChBUcmFja1RyYW5zYWN0aW9uEikudGhydS5zZXJ2aWNlcy52MS5UcmFja1RyYW5zYWN0aW9uUmVxdWVzdBoqLnRocnUuc2VydmljZXMudjEuVHJhY2tUcmFuc2FjdGlvblJlc3BvbnNlMAESXwoMU3RyZWFtSGVpZ2h0EiUudGhydS5zZXJ2aWNlcy52MS5TdHJlYW1IZWlnaHRSZXF1ZXN0GiYudGhydS5zZXJ2aWNlcy52MS5TdHJlYW1IZWlnaHRSZXNwb25zZTABQuABChRjb20udGhydS5zZXJ2aWNlcy52MUIVU3RyZWFtaW5nU2VydmljZVByb3RvUAFaSGdpdGh1Yi5jb20vVW50by1MYWJzL3RocnUtbmV0L2dycGMvcGtnL3Byb3RvL3RocnUvc2VydmljZXMvdjE7c2VydmljZXN2MaICA1RTWKoCEFRocnUuU2VydmljZXMuVjG6AgRUSFVTygIQVGhydVxTZXJ2aWNlc1xWMeICHFRocnVcU2VydmljZXNcVjFcR1BCTWV0YWRhdGHqAhJUaHJ1OjpTZXJ2aWNlczo6VjFiBnByb3RvMw", [file_buf_validate_validate, file_google_api_field_behavior, file_thru_common_v1_primitives, file_google_protobuf_duration, file_google_protobuf_timestamp, file_thru_common_v1_consensus, file_thru_common_v1_filters, file_thru_core_v1_account, file_thru_core_v1_block, file_thru_core_v1_transaction, file_thru_core_v1_types]);

/**
 * StreamBlocksRequest subscribes to real-time block updates.
 *
 * Filter expressions support the following params:
 *
 * - params.slot (int64): Slot number for comparison
 *   Example: block.block.header.slot == params.slot
 *
 * - params.min_slot (int64): Minimum slot for range filtering
 *   Example: block.block.header.slot >= params.min_slot
 *
 * - params.start_slot (int64): Starting slot for filtering
 *   Example: block.block.header.slot >= params.start_slot
 *
 * - params.u64 (int64): Generic 64-bit value for numeric comparisons
 *   Examples:
 *     block.block.header.max_compute_units > params.u64
 *     block.block.header.bond_amount_lock_up >= params.u64
 *
 * - params.producer (bytes|Pubkey): Producer pubkey for filtering
 *   Examples:
 *     block.block.header.producer.value == params.producer
 *     has(block.block.header.producer) && block.block.header.producer.value == params.producer
 *
 * Available block header fields:
 *   block.block.header.slot, block.block.header.version,
 *   block.block.header.start_slot, block.block.header.expiry_after,
 *   block.block.header.max_block_size, block.block.header.max_compute_units,
 *   block.block.header.max_state_units, block.block.header.bond_amount_lock_up,
 *   block.block.header.producer, block.block.header.producer.value
 *
 * Available block footer fields:
 *   block.block.footer.status, block.block.footer.consumed_compute_units,
 *   block.block.footer.consumed_state_units, block.block.footer.attestor_payment
 *
 * Available consensus status field:
 *   block.block.consensus_status
 *
 * Filter expression examples:
 *
 * 1. Filter by specific slot:
 *    Expression: "block.block.header.slot == params.slot"
 *    Params: {"slot": 12345}
 *
 * 2. Filter by slot range:
 *    Expression: "block.block.header.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 3. Filter by block version:
 *    Expression: "block.block.header.version >= uint(0)"
 *
 * 4. Filter by specific producer:
 *    Expression: "has(block.block.header.producer) && block.block.header.producer.value == params.producer"
 *    Params: {"producer": <32-byte pubkey>}
 *
 * 5. Filter by max compute units:
 *    Expression: "block.block.header.max_compute_units > uint(0)"
 *
 * 6. Filter by max state units:
 *    Expression: "block.block.header.max_state_units > uint(0)"
 *
 * 7. Filter by bond amount lock-up:
 *    Expression: "block.block.header.bond_amount_lock_up >= uint(0)"
 *
 * 8. Filter by footer status:
 *    Expression: "has(block.block.footer) && block.block.footer.status == int(1)"
 *    Note: EXECUTION_STATUS_PENDING = 1, EXECUTION_STATUS_EXECUTED = 2
 *
 * 9. Filter by consumed compute units:
 *    Expression: "has(block.block.footer) && block.block.footer.consumed_compute_units > uint(0)"
 *
 * 10. Filter by consumed state units:
 *     Expression: "has(block.block.footer) && block.block.footer.consumed_state_units > uint(0)"
 *
 * 11. Filter by consensus status:
 *     Expression: "block.block.consensus_status == int(2)"
 *     Note: CONSENSUS_STATUS_UNSPECIFIED = 0, CONSENSUS_STATUS_OBSERVED = 1,
 *           CONSENSUS_STATUS_INCLUDED = 2
 *
 * 12. Check for optional fields presence:
 *     Expression: "has(block.block.header) && has(block.block.footer)"
 *
 * 13. Combined filters (multiple conditions):
 *     Expression: "block.block.header.slot >= params.min_slot && has(block.block.footer) && block.block.footer.consumed_compute_units > uint(0)"
 *     Params: {"min_slot": 1000}
 *
 * 14. Numeric comparison with params:
 *     Expression: "block.block.header.max_compute_units > params.u64"
 *     Params: {"u64": 1000000}
 *
 * @generated from message thru.services.v1.StreamBlocksRequest
 */
export type StreamBlocksRequest = Message<"thru.services.v1.StreamBlocksRequest"> & {
  /**
   * @generated from field: optional uint64 start_slot = 1;
   */
  startSlot?: bigint;

  /**
   * @generated from field: optional thru.common.v1.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.core.v1.BlockView view = 3;
   */
  view?: BlockView;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;
};

/**
 * Describes the message thru.services.v1.StreamBlocksRequest.
 * Use `create(StreamBlocksRequestSchema)` to create a new message.
 */
export const StreamBlocksRequestSchema: GenMessage<StreamBlocksRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 0);

/**
 * StreamBlocksResponse delivers block updates.
 *
 * @generated from message thru.services.v1.StreamBlocksResponse
 */
export type StreamBlocksResponse = Message<"thru.services.v1.StreamBlocksResponse"> & {
  /**
   * @generated from field: thru.core.v1.Block block = 1;
   */
  block?: Block;
};

/**
 * Describes the message thru.services.v1.StreamBlocksResponse.
 * Use `create(StreamBlocksResponseSchema)` to create a new message.
 */
export const StreamBlocksResponseSchema: GenMessage<StreamBlocksResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 1);

/**
 * StreamAccountUpdatesRequest subscribes to account delta events.
 *
 * Filter expressions support the following params:
 *
 * - params.min_slot (uint64): Minimum slot for filtering updates
 *   Example: account_update.slot >= params.min_slot
 *
 * - params.min_balance (uint64): Minimum balance for filtering
 *   Example: snapshot.meta.balance >= params.min_balance
 *
 * - params.owner (bytes|Pubkey): Owner pubkey for filtering
 *   Examples:
 *     snapshot.meta.owner.value == params.owner
 *     account_update.meta.owner.value == params.owner
 *
 * - params.address (bytes|Pubkey): Account address for filtering
 *   Example: account_address.value == params.address
 *   Note: Use account_address for unified filtering across both snapshot and update messages
 *
 * - params.addresses (BytesList): List of addresses for multi-account filtering
 *   Example: account_address.value in params.addresses
 *   Note: Use the 'in' operator to filter by multiple addresses in a single subscription
 *
 * - params.min_nonce (uint64): Minimum nonce for filtering
 *   Example: snapshot.meta.nonce >= params.min_nonce
 *
 * - params.min_seq (uint64): Minimum sequence number for filtering
 *   Example: snapshot.meta.seq >= params.min_seq
 *
 * - params.min_data_size (uint32): Minimum data size for filtering
 *   Example: snapshot.meta.data_size >= params.min_data_size
 *
 * Available snapshot fields (thru.core.v1.Account):
 *   snapshot.address, snapshot.address.value (bytes),
 *   snapshot.meta.balance (uint64), snapshot.meta.seq (uint64),
 *   snapshot.meta.nonce (uint64), snapshot.meta.data_size (uint32),
 *   snapshot.meta.version (uint32), snapshot.meta.flags (AccountFlags),
 *   snapshot.meta.flags.is_program (bool), snapshot.meta.flags.is_privileged (bool),
 *   snapshot.meta.flags.is_uncompressable (bool), snapshot.meta.flags.is_ephemeral (bool),
 *   snapshot.meta.flags.is_deleted (bool), snapshot.meta.flags.is_new (bool),
 *   snapshot.meta.flags.is_compressed (bool),
 *   snapshot.meta.owner, snapshot.meta.owner.value (bytes)
 *
 * Available account_update fields (AccountUpdate):
 *   account_update.slot (uint64), account_update.delete (bool),
 *   account_update.meta.balance (uint64), account_update.meta.seq (uint64),
 *   account_update.meta.nonce (uint64), account_update.meta.data_size (uint32),
 *   account_update.meta.version (uint32), account_update.meta.flags (AccountFlags),
 *   account_update.meta.flags.is_program (bool), account_update.meta.flags.is_privileged (bool),
 *   account_update.meta.flags.is_uncompressable (bool), account_update.meta.flags.is_ephemeral (bool),
 *   account_update.meta.flags.is_deleted (bool), account_update.meta.flags.is_new (bool),
 *   account_update.meta.flags.is_compressed (bool),
 *   account_update.meta.owner, account_update.meta.owner.value (bytes)
 *
 * Available unified fields (work for both snapshot and update messages):
 *   account_address, account_address.value (bytes) - extracted from whichever message type is present
 *
 * Filter expression examples:
 *
 * 1. Filter by minimum balance (snapshot or update):
 *    Expression: "(has(snapshot.meta) && snapshot.meta.balance >= uint(1000000)) || (has(account_update.meta) && account_update.meta.balance >= uint(1000000))"
 *
 * 2. Filter by account owner using params:
 *    Expression: "(has(snapshot.meta) && has(snapshot.meta.owner) && snapshot.meta.owner.value == params.owner) || (has(account_update.meta) && has(account_update.meta.owner) && account_update.meta.owner.value == params.owner)"
 *    Params: {"owner": <32-byte pubkey>}
 *
 * 3. Filter by specific account address (works for both snapshot and update messages):
 *    Expression: "account_address.value == params.address"
 *    Params: {"address": <32-byte pubkey>}
 *
 * 4. Filter by minimum slot for updates:
 *    Expression: "has(account_update.meta) && account_update.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 5. Filter by nonce greater than value:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.nonce >= uint(5)) || (has(account_update.meta) && account_update.meta.nonce >= uint(5))"
 *
 * 6. Filter by sequence number:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.seq >= uint(100)) || (has(account_update.meta) && account_update.meta.seq >= uint(100))"
 *
 * 7. Filter by data size:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.data_size >= uint(1024)) || (has(account_update.meta) && account_update.meta.data_size >= uint(1024))"
 *
 * 8. Filter by account version:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.version >= uint(1)) || (has(account_update.meta) && account_update.meta.version >= uint(1))"
 *
 * 9. Filter by account flags (check if account is a program):
 *    Expression: "(has(snapshot.meta) && has(snapshot.meta.flags) && snapshot.meta.flags.is_program) || (has(account_update.meta) && has(account_update.meta.flags) && account_update.meta.flags.is_program)"
 *
 * 10. Filter by privileged flag:
 *     Expression: "(has(snapshot.meta) && has(snapshot.meta.flags) && snapshot.meta.flags.is_privileged) || (has(account_update.meta) && has(account_update.meta.flags) && account_update.meta.flags.is_privileged)"
 *
 * 11. Filter non-delete updates:
 *     Expression: "has(snapshot.meta) || (has(account_update.meta) && (!has(account_update.delete) || !account_update.delete))"
 *
 * 12. Check for snapshot or update presence:
 *     Expression: "has(snapshot.meta) || has(account_update.meta)"
 *
 * 13. Combined filters (multiple conditions):
 *     Expression: "has(snapshot.meta) || (has(account_update.meta) && account_update.slot >= params.min_slot && account_update.meta.balance >= params.min_balance)"
 *     Params: {"min_slot": 1000, "min_balance": 1000000}
 *
 * 14. Filter by minimum balance using params:
 *     Expression: "(has(snapshot.meta) && snapshot.meta.balance >= params.min_balance) || (has(account_update.meta) && account_update.meta.balance >= params.min_balance)"
 *     Params: {"min_balance": 5000000000}
 *
 * Note: The response contains either a snapshot (initial state), an update (delta),
 * or a BlockFinished message. Filters should handle both snapshot and update cases
 * using OR logic to match either message type.
 *
 * To filter by specific account address (recommended - works for both message types):
 *   Expression: "account_address.value == params.address"
 *   Params: {"address": <32-byte pubkey>}
 *
 * To filter by owner (program):
 *   Expression: "(has(snapshot.meta.owner) && snapshot.meta.owner.value == params.owner) || (has(account_update.meta.owner) && account_update.meta.owner.value == params.owner)"
 *   Params: {"owner": <32-byte program pubkey>}
 *
 * To filter by multiple account addresses (recommended for multi-account subscriptions):
 *   Expression: "account_address.value in params.addresses"
 *   Params: {"addresses": BytesList{values: [<pubkey1>, <pubkey2>, ...]}}
 *   Note: Use BytesList parameter type with the 'in' operator for efficient multi-address filtering
 *
 * @generated from message thru.services.v1.StreamAccountUpdatesRequest
 */
export type StreamAccountUpdatesRequest = Message<"thru.services.v1.StreamAccountUpdatesRequest"> & {
  /**
   * @generated from field: optional thru.core.v1.AccountView view = 2;
   */
  view?: AccountView;

  /**
   * @generated from field: optional thru.common.v1.Filter filter = 4;
   */
  filter?: Filter;
};

/**
 * Describes the message thru.services.v1.StreamAccountUpdatesRequest.
 * Use `create(StreamAccountUpdatesRequestSchema)` to create a new message.
 */
export const StreamAccountUpdatesRequestSchema: GenMessage<StreamAccountUpdatesRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 2);

/**
 * AccountUpdate describes a delta for an account.
 *
 * @generated from message thru.services.v1.AccountUpdate
 */
export type AccountUpdate = Message<"thru.services.v1.AccountUpdate"> & {
  /**
   * @generated from field: uint64 slot = 1;
   */
  slot: bigint;

  /**
   * @generated from field: optional thru.core.v1.AccountPage page = 2;
   */
  page?: AccountPage;

  /**
   * @generated from field: optional thru.core.v1.AccountMeta meta = 3;
   */
  meta?: AccountMeta;

  /**
   * @generated from field: optional bool delete = 4;
   */
  delete?: boolean;

  /**
   * Account address for identifying the account in multi-account streams.
   *
   * @generated from field: thru.common.v1.Pubkey address = 5;
   */
  address?: Pubkey;
};

/**
 * Describes the message thru.services.v1.AccountUpdate.
 * Use `create(AccountUpdateSchema)` to create a new message.
 */
export const AccountUpdateSchema: GenMessage<AccountUpdate> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 3);

/**
 * BlockFinished is sent when block's execution is complete.
 *
 * @generated from message thru.services.v1.BlockFinished
 */
export type BlockFinished = Message<"thru.services.v1.BlockFinished"> & {
  /**
   * @generated from field: uint64 slot = 1;
   */
  slot: bigint;
};

/**
 * Describes the message thru.services.v1.BlockFinished.
 * Use `create(BlockFinishedSchema)` to create a new message.
 */
export const BlockFinishedSchema: GenMessage<BlockFinished> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 4);

/**
 * StreamAccountUpdatesResponse contains either an initial snapshot or a delta.
 *
 * @generated from message thru.services.v1.StreamAccountUpdatesResponse
 */
export type StreamAccountUpdatesResponse = Message<"thru.services.v1.StreamAccountUpdatesResponse"> & {
  /**
   * @generated from oneof thru.services.v1.StreamAccountUpdatesResponse.message
   */
  message: {
    /**
     * @generated from field: thru.core.v1.Account snapshot = 1;
     */
    value: Account;
    case: "snapshot";
  } | {
    /**
     * @generated from field: thru.services.v1.AccountUpdate update = 2;
     */
    value: AccountUpdate;
    case: "update";
  } | {
    /**
     * @generated from field: thru.services.v1.BlockFinished finished = 3;
     */
    value: BlockFinished;
    case: "finished";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message thru.services.v1.StreamAccountUpdatesResponse.
 * Use `create(StreamAccountUpdatesResponseSchema)` to create a new message.
 */
export const StreamAccountUpdatesResponseSchema: GenMessage<StreamAccountUpdatesResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 5);

/**
 * StreamTransactionsRequest subscribes to transaction confirmations.
 *
 * Filter expressions support the following params:
 *
 * - params.min_slot (uint64): Minimum slot for filtering transactions
 *   Example: transaction.slot >= params.min_slot
 *
 * - params.max_slot (uint64): Maximum slot for filtering transactions
 *   Example: transaction.slot <= params.max_slot
 *
 * - params.slot (uint64): Specific slot for exact match filtering
 *   Example: transaction.slot == params.slot
 *
 * - params.min_fee (uint64): Minimum fee for filtering transactions
 *   Example: transaction.header.fee >= params.min_fee
 *
 * - params.fee_payer (bytes|Pubkey): Fee payer pubkey for filtering
 *   Example: transaction.header.fee_payer_pubkey.value == params.fee_payer
 *
 * - params.signature (bytes|Signature): Transaction signature for filtering
 *   Example: transaction.signature.value == params.signature
 *
 * Available transaction fields (thru.core.v1.Transaction):
 *   transaction.signature, transaction.signature.value (bytes),
 *   transaction.slot (uint64), transaction.block_offset (uint32),
 *   transaction.header, transaction.header.version (uint32),
 *   transaction.header.fee (uint64),
 *   transaction.header.fee_payer_pubkey, transaction.header.fee_payer_pubkey.value (bytes),
 *   transaction.execution_result, transaction.execution_result.user_error_code (uint32),
 *   transaction.execution_result.vm_error (int32)
 *
 * Available consensus_status field:
 *   consensus_status (int32) - Current consensus status of the transaction
 *   Values: CONSENSUS_STATUS_UNSPECIFIED = 0, CONSENSUS_STATUS_OBSERVED = 1,
 *           CONSENSUS_STATUS_INCLUDED = 2
 *
 * Filter expression examples:
 *
 * 1. Filter by minimum slot:
 *    Expression: "has(transaction.slot) && transaction.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 2. Filter by slot range:
 *    Expression: "has(transaction.slot) && transaction.slot >= params.min_slot && transaction.slot <= params.max_slot"
 *    Params: {"min_slot": 1000, "max_slot": 2000}
 *
 * 3. Filter by specific slot:
 *    Expression: "has(transaction.slot) && transaction.slot == params.slot"
 *    Params: {"slot": 12345}
 *
 * 4. Filter by minimum fee:
 *    Expression: "has(transaction.header) && transaction.header.fee >= params.min_fee"
 *    Params: {"min_fee": 5000}
 *
 * 5. Filter by fee payer:
 *    Expression: "has(transaction.header.fee_payer_pubkey) && transaction.header.fee_payer_pubkey.value == params.fee_payer"
 *    Params: {"fee_payer": <32-byte pubkey>}
 *
 * 6. Filter by transaction signature:
 *    Expression: "has(transaction.signature) && transaction.signature.value == params.signature"
 *    Params: {"signature": <64-byte signature>}
 *
 * 7. Filter by header version:
 *    Expression: "has(transaction.header) && transaction.header.version >= uint(0)"
 *
 * 8. Filter by successful execution:
 *    Expression: "has(transaction.execution_result) && transaction.execution_result.vm_error == int(0)"
 *
 * 9. Filter by user error code:
 *    Expression: "has(transaction.execution_result) && transaction.execution_result.user_error_code == uint(0)"
 *
 * 10. Filter by consensus status:
 *     Expression: "consensus_status >= int(2)"
 *     Note: Use >= int(2) for CONSENSUS_STATUS_INCLUDED and above
 *
 * 11. Check for execution result presence:
 *     Expression: "has(transaction.execution_result)"
 *
 * 12. Filter by transaction with header and slot:
 *     Expression: "has(transaction.slot) && transaction.slot >= uint(0) && has(transaction.header)"
 *
 * 13. Combined filters (slot, fee, and status):
 *     Expression: "has(transaction.slot) && transaction.slot >= params.min_slot && has(transaction.header) && transaction.header.fee >= params.min_fee && consensus_status >= int(2)"
 *     Params: {"min_slot": 1000, "min_fee": 5000}
 *
 * 14. Filter successful transactions with minimum fee:
 *     Expression: "has(transaction.execution_result) && transaction.execution_result.vm_error == int(0) && has(transaction.header) && transaction.header.fee >= params.min_fee"
 *     Params: {"min_fee": 10000}
 *
 * Note: The min_consensus field in the request provides built-in consensus filtering
 * without requiring a CEL expression. Use it in combination with filter expressions
 * for more complex filtering logic.
 *
 * @generated from message thru.services.v1.StreamTransactionsRequest
 */
export type StreamTransactionsRequest = Message<"thru.services.v1.StreamTransactionsRequest"> & {
  /**
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 2;
   */
  minConsensus?: ConsensusStatus;
};

/**
 * Describes the message thru.services.v1.StreamTransactionsRequest.
 * Use `create(StreamTransactionsRequestSchema)` to create a new message.
 */
export const StreamTransactionsRequestSchema: GenMessage<StreamTransactionsRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 6);

/**
 * StreamTransactionsResponse delivers transaction events.
 *
 * @generated from message thru.services.v1.StreamTransactionsResponse
 */
export type StreamTransactionsResponse = Message<"thru.services.v1.StreamTransactionsResponse"> & {
  /**
   * @generated from field: thru.core.v1.Transaction transaction = 1;
   */
  transaction?: Transaction;
};

/**
 * Describes the message thru.services.v1.StreamTransactionsResponse.
 * Use `create(StreamTransactionsResponseSchema)` to create a new message.
 */
export const StreamTransactionsResponseSchema: GenMessage<StreamTransactionsResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 7);

/**
 * StreamEventsRequest subscribes to chain events.
 *
 * Filter expressions support the following params:
 *
 * - params.prefix (bytes): Byte prefix for payload filtering
 *   Example: bytesPrefix(event.payload, params.prefix)
 *
 * - params.slot (int64): Slot number for comparison
 *   Example: event.slot >= params.slot
 *
 * - params.u64 (int64): Generic 64-bit value for payload extraction
 *   Examples:
 *     first8Bytes(event.payload) == params.u64
 *     first4Bytes(event.payload) == params.u64
 *     first1Byte(event.payload) == params.u64
 *
 * - params.signature (bytes|Signature|TsSignature): Signature for comparison
 *   Examples:
 *     event.signature.value == params.signature        // bytes type
 *     bytesPrefix(event.signature.value, params.signature)
 *   Note: Signature and TsSignature types are auto-converted to bytes
 *
 * - params.address (bytes|Pubkey|TaPubkey): Address/pubkey for comparison
 *   Examples:
 *     event.program.value == params.address            // bytes type
 *     bytesPrefix(event.program.value, params.address)
 *   Note: Pubkey and TaPubkey types are auto-converted to bytes
 *
 * - params.timestamp (int64): Timestamp in seconds for comparison
 *   Example: int(event.timestamp) > params.timestamp
 *
 * Available event fields:
 *   event.event_id (string), event.slot (uint64), event.payload (bytes),
 *   event.call_idx (uint32), event.signature (Signature),
 *   event.signature.value (bytes), event.program (Pubkey),
 *   event.program.value (bytes), event.timestamp (Timestamp)
 *
 * Note: Unlike ListEventsRequest in QueryService, StreamEventsRequest does NOT support:
 *   event.block_offset, event.program_idx, event.payload_size, event.transaction_signature
 *
 * Available filter functions:
 *   - has(field): Check if optional field exists
 *     Example: has(event.program) && has(event.signature)
 *
 *   - startsWith(string, prefix): Check if string starts with prefix
 *     Example: event.event_id.startsWith("ts")
 *
 *   - bytesPrefix(bytes, prefix): Check if bytes start with prefix
 *     Examples:
 *       bytesPrefix(event.payload, b"\x01\x00\x00\x00\x00\x00\x00\x00")
 *       bytesPrefix(event.payload, params.prefix)
 *       bytesPrefix(event.program.value, params.address)
 *       bytesPrefix(event.signature.value, params.signature)
 *
 *   - first1Byte(bytes): Extract first byte as uint
 *     Example: first1Byte(event.payload) == uint(1)
 *
 *   - first4Bytes(bytes): Extract first 4 bytes as little-endian uint32
 *     Example: first4Bytes(event.payload) == uint(2)
 *
 *   - first8Bytes(bytes): Extract first 8 bytes as little-endian uint64
 *     Example: first8Bytes(event.payload) == uint(6)
 *
 *   - uint(value): Convert value to uint for comparison
 *   - int(value): Convert value to int (used for timestamps)
 *
 * Filter expression examples:
 *
 * 1. Filter by payload type using first1Byte (MESSAGE event type = 1):
 *    Expression: "first1Byte(event.payload) == uint(1)"
 *
 * 2. Filter by payload type using first4Bytes (COUNTER event type = 2):
 *    Expression: "first4Bytes(event.payload) == uint(2)"
 *
 * 3. Filter by payload type using first8Bytes (PATTERN event type = 6):
 *    Expression: "first8Bytes(event.payload) == uint(6)"
 *
 * 4. Filter by payload prefix with params:
 *    Expression: "bytesPrefix(event.payload, params.prefix)"
 *    Params: {"prefix": <bytes, e.g., 0x01000000...>}
 *
 * 5. Filter by slot using params:
 *    Expression: "event.slot >= params.slot"
 *    Params: {"slot": 1000}
 *
 * 6. Filter by program address (exact match):
 *    Expression: "event.program.value == params.address"
 *    Params: {"address": <32-byte pubkey as bytes, Pubkey, or TaPubkey>}
 *
 * 7. Filter by program address (prefix match):
 *    Expression: "bytesPrefix(event.program.value, params.address)"
 *    Params: {"address": <pubkey prefix bytes>}
 *
 * 8. Filter by transaction signature (exact match):
 *    Expression: "event.signature.value == params.signature"
 *    Params: {"signature": <64-byte signature as bytes, Signature, or TsSignature>}
 *
 * 9. Filter by transaction signature (prefix match):
 *    Expression: "bytesPrefix(event.signature.value, params.signature)"
 *    Params: {"signature": <signature prefix bytes>}
 *
 * 10. Filter by call_idx (0 = main program, 1+ = CPI calls):
 *     Expression: "event.call_idx == uint(0)"
 *     Expression: "event.call_idx == uint(1)"
 *
 * 11. Filter by event_id prefix:
 *     Expression: "event.event_id.startsWith(\"ts\")"
 *
 * 12. Filter by timestamp (events in last hour):
 *     Expression: "has(event.timestamp) && int(event.timestamp) > int(1700000000)"
 *
 * 13. Filter by timestamp using params:
 *     Expression: "has(event.timestamp) && int(event.timestamp) > params.timestamp"
 *     Params: {"timestamp": 1700000000}
 *
 * 14. Check field existence:
 *     Expression: "has(event.program) && has(event.signature)"
 *
 * 15. Filter using params.u64 with first8Bytes:
 *     Expression: "first8Bytes(event.payload) == params.u64"
 *     Params: {"u64": 6}
 *
 * 16. Filter using params.u64 with first4Bytes:
 *     Expression: "first4Bytes(event.payload) == params.u64"
 *     Params: {"u64": 2}
 *
 * 17. Filter using params.u64 with first1Byte:
 *     Expression: "first1Byte(event.payload) == params.u64"
 *     Params: {"u64": 1}
 *
 * 18. Combined filter (slot + payload type + call_idx):
 *     Expression: "event.slot > uint(1000) && first1Byte(event.payload) == uint(1) && event.call_idx == uint(0)"
 *
 * 19. Combined filter (call_idx + program address):
 *     Expression: "event.call_idx == uint(1) && event.program.value == params.address"
 *     Params: {"address": <32-byte CPI target program pubkey>}
 *
 * 20. Timestamp range filter:
 *     Expression: "has(event.timestamp) && int(event.timestamp) > int(1700000000) && int(event.timestamp) < int(1700100000)"
 *
 * @generated from message thru.services.v1.StreamEventsRequest
 */
export type StreamEventsRequest = Message<"thru.services.v1.StreamEventsRequest"> & {
  /**
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;
};

/**
 * Describes the message thru.services.v1.StreamEventsRequest.
 * Use `create(StreamEventsRequestSchema)` to create a new message.
 */
export const StreamEventsRequestSchema: GenMessage<StreamEventsRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 8);

/**
 * StreamEventsResponse delivers event payloads.
 *
 * @generated from message thru.services.v1.StreamEventsResponse
 */
export type StreamEventsResponse = Message<"thru.services.v1.StreamEventsResponse"> & {
  /**
   * @generated from field: string event_id = 1;
   */
  eventId: string;

  /**
   * @generated from field: optional bytes payload = 2;
   */
  payload?: Uint8Array;

  /**
   * @generated from field: optional google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: thru.common.v1.Pubkey program = 4;
   */
  program?: Pubkey;

  /**
   * @generated from field: uint32 call_idx = 5;
   */
  callIdx: number;

  /**
   * @generated from field: thru.common.v1.Signature signature = 6;
   */
  signature?: Signature;

  /**
   * @generated from field: uint64 slot = 7;
   */
  slot: bigint;
};

/**
 * Describes the message thru.services.v1.StreamEventsResponse.
 * Use `create(StreamEventsResponseSchema)` to create a new message.
 */
export const StreamEventsResponseSchema: GenMessage<StreamEventsResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 9);

/**
 * TrackTransactionRequest subscribes to status updates for a transaction.
 *
 * @generated from message thru.services.v1.TrackTransactionRequest
 */
export type TrackTransactionRequest = Message<"thru.services.v1.TrackTransactionRequest"> & {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: optional google.protobuf.Duration timeout = 2;
   */
  timeout?: Duration;
};

/**
 * Describes the message thru.services.v1.TrackTransactionRequest.
 * Use `create(TrackTransactionRequestSchema)` to create a new message.
 */
export const TrackTransactionRequestSchema: GenMessage<TrackTransactionRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 10);

/**
 * TrackTransactionResponse reports status transitions for a transaction.
 *
 * @generated from message thru.services.v1.TrackTransactionResponse
 */
export type TrackTransactionResponse = Message<"thru.services.v1.TrackTransactionResponse"> & {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: thru.common.v1.ConsensusStatus consensus_status = 2;
   */
  consensusStatus: ConsensusStatus;

  /**
   * @generated from field: thru.core.v1.TransactionExecutionResult execution_result = 3;
   */
  executionResult?: TransactionExecutionResult;
};

/**
 * Describes the message thru.services.v1.TrackTransactionResponse.
 * Use `create(TrackTransactionResponseSchema)` to create a new message.
 */
export const TrackTransactionResponseSchema: GenMessage<TrackTransactionResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 11);

/**
 * StreamHeightRequest subscribes to real-time height updates.
 *
 * @generated from message thru.services.v1.StreamHeightRequest
 */
export type StreamHeightRequest = Message<"thru.services.v1.StreamHeightRequest"> & {
};

/**
 * Describes the message thru.services.v1.StreamHeightRequest.
 * Use `create(StreamHeightRequestSchema)` to create a new message.
 */
export const StreamHeightRequestSchema: GenMessage<StreamHeightRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 12);

/**
 * StreamHeightResponse delivers height update events.
 *
 * @generated from message thru.services.v1.StreamHeightResponse
 */
export type StreamHeightResponse = Message<"thru.services.v1.StreamHeightResponse"> & {
  /**
   * @generated from field: uint64 finalized = 1;
   */
  finalized: bigint;

  /**
   * @generated from field: uint64 locally_executed = 2;
   */
  locallyExecuted: bigint;

  /**
   * @generated from field: uint64 cluster_executed = 3;
   */
  clusterExecuted: bigint;
};

/**
 * Describes the message thru.services.v1.StreamHeightResponse.
 * Use `create(StreamHeightResponseSchema)` to create a new message.
 */
export const StreamHeightResponseSchema: GenMessage<StreamHeightResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 13);

/**
 * StreamingService serves server-streaming gRPC APIs for real-time data.
 *
 * @generated from service thru.services.v1.StreamingService
 */
export const StreamingService: GenService<{
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamBlocks
   */
  streamBlocks: {
    methodKind: "server_streaming";
    input: typeof StreamBlocksRequestSchema;
    output: typeof StreamBlocksResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamAccountUpdates
   */
  streamAccountUpdates: {
    methodKind: "server_streaming";
    input: typeof StreamAccountUpdatesRequestSchema;
    output: typeof StreamAccountUpdatesResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamTransactions
   */
  streamTransactions: {
    methodKind: "server_streaming";
    input: typeof StreamTransactionsRequestSchema;
    output: typeof StreamTransactionsResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamEvents
   */
  streamEvents: {
    methodKind: "server_streaming";
    input: typeof StreamEventsRequestSchema;
    output: typeof StreamEventsResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.TrackTransaction
   */
  trackTransaction: {
    methodKind: "server_streaming";
    input: typeof TrackTransactionRequestSchema;
    output: typeof TrackTransactionResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamHeight
   */
  streamHeight: {
    methodKind: "server_streaming";
    input: typeof StreamHeightRequestSchema;
    output: typeof StreamHeightResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_thru_services_v1_streaming_service, 0);

