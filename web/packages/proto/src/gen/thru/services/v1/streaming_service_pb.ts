// @generated by protoc-gen-es v2.10.1 with parameter "target=ts"
// @generated from file thru/services/v1/streaming_service.proto (package thru.services.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_buf_validate_validate } from "../../../buf/validate/validate_pb";
import { file_google_api_field_behavior } from "../../../google/api/field_behavior_pb";
import type { Pubkey, Signature } from "../../common/v1/primitives_pb";
import { file_thru_common_v1_primitives } from "../../common/v1/primitives_pb";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { ConsensusStatus } from "../../common/v1/consensus_pb";
import { file_thru_common_v1_consensus } from "../../common/v1/consensus_pb";
import type { Filter } from "../../common/v1/filters_pb";
import { file_thru_common_v1_filters } from "../../common/v1/filters_pb";
import type { Account, AccountMeta, AccountPage, AccountView } from "../../core/v1/account_pb";
import { file_thru_core_v1_account } from "../../core/v1/account_pb";
import type { Block, BlockView } from "../../core/v1/block_pb";
import { file_thru_core_v1_block } from "../../core/v1/block_pb";
import type { Transaction, TransactionExecutionResult } from "../../core/v1/transaction_pb";
import { file_thru_core_v1_transaction } from "../../core/v1/transaction_pb";
import { file_thru_core_v1_types } from "../../core/v1/types_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file thru/services/v1/streaming_service.proto.
 */
export const file_thru_services_v1_streaming_service: GenFile = /*@__PURE__*/
  fileDesc("Cih0aHJ1L3NlcnZpY2VzL3YxL3N0cmVhbWluZ19zZXJ2aWNlLnByb3RvEhB0aHJ1LnNlcnZpY2VzLnYxIo0CChNTdHJlYW1CbG9ja3NSZXF1ZXN0EhwKCnN0YXJ0X3Nsb3QYASABKARCA+BBAUgAiAEBEjAKBmZpbHRlchgCIAEoCzIWLnRocnUuY29tbW9uLnYxLkZpbHRlckID4EEBSAGIAQESLwoEdmlldxgDIAEoDjIXLnRocnUuY29yZS52MS5CbG9ja1ZpZXdCA+BBAUgCiAEBEkAKDW1pbl9jb25zZW5zdXMYBCABKA4yHy50aHJ1LmNvbW1vbi52MS5Db25zZW5zdXNTdGF0dXNCA+BBAUgDiAEBQg0KC19zdGFydF9zbG90QgkKB19maWx0ZXJCBwoFX3ZpZXdCEAoOX21pbl9jb25zZW5zdXMiPwoUU3RyZWFtQmxvY2tzUmVzcG9uc2USJwoFYmxvY2sYASABKAsyEy50aHJ1LmNvcmUudjEuQmxvY2tCA+BBAiKcAQobU3RyZWFtQWNjb3VudFVwZGF0ZXNSZXF1ZXN0EjEKBHZpZXcYAiABKA4yGS50aHJ1LmNvcmUudjEuQWNjb3VudFZpZXdCA+BBAUgAiAEBEjAKBmZpbHRlchgEIAEoCzIWLnRocnUuY29tbW9uLnYxLkZpbHRlckID4EEBSAGIAQFCBwoFX3ZpZXdCCQoHX2ZpbHRlckoECAEQAiLtAQoNQWNjb3VudFVwZGF0ZRIRCgRzbG90GAEgASgEQgPgQQISMQoEcGFnZRgCIAEoCzIZLnRocnUuY29yZS52MS5BY2NvdW50UGFnZUID4EEBSACIAQESMQoEbWV0YRgDIAEoCzIZLnRocnUuY29yZS52MS5BY2NvdW50TWV0YUID4EEBSAGIAQESGAoGZGVsZXRlGAQgASgIQgPgQQFIAogBARIsCgdhZGRyZXNzGAUgASgLMhYudGhydS5jb21tb24udjEuUHVia2V5QgPgQQJCBwoFX3BhZ2VCBwoFX21ldGFCCQoHX2RlbGV0ZSKbAQoNQmxvY2tGaW5pc2hlZBIRCgRzbG90GAEgASgEQgPgQQISKwoeZ2xvYmFsX2FjdGl2YXRlZF9zdGF0ZV9jb3VudGVyGAIgASgEQgPgQQISLQogZ2xvYmFsX2RlYWN0aXZhdGVkX3N0YXRlX2NvdW50ZXIYAyABKARCA+BBAhIbCg5jb2xsZWN0ZWRfZmVlcxgEIAEoBEID4EECIrwBChxTdHJlYW1BY2NvdW50VXBkYXRlc1Jlc3BvbnNlEikKCHNuYXBzaG90GAEgASgLMhUudGhydS5jb3JlLnYxLkFjY291bnRIABIxCgZ1cGRhdGUYAiABKAsyHy50aHJ1LnNlcnZpY2VzLnYxLkFjY291bnRVcGRhdGVIABIzCghmaW5pc2hlZBgDIAEoCzIfLnRocnUuc2VydmljZXMudjEuQmxvY2tGaW5pc2hlZEgAQgkKB21lc3NhZ2UirAEKGVN0cmVhbVRyYW5zYWN0aW9uc1JlcXVlc3QSMAoGZmlsdGVyGAEgASgLMhYudGhydS5jb21tb24udjEuRmlsdGVyQgPgQQFIAIgBARJACg1taW5fY29uc2Vuc3VzGAIgASgOMh8udGhydS5jb21tb24udjEuQ29uc2Vuc3VzU3RhdHVzQgPgQQFIAYgBAUIJCgdfZmlsdGVyQhAKDl9taW5fY29uc2Vuc3VzIlEKGlN0cmVhbVRyYW5zYWN0aW9uc1Jlc3BvbnNlEjMKC3RyYW5zYWN0aW9uGAEgASgLMhkudGhydS5jb3JlLnYxLlRyYW5zYWN0aW9uQgPgQQIiUgoTU3RyZWFtRXZlbnRzUmVxdWVzdBIwCgZmaWx0ZXIYASABKAsyFi50aHJ1LmNvbW1vbi52MS5GaWx0ZXJCA+BBAUgAiAEBQgkKB19maWx0ZXIipgIKFFN0cmVhbUV2ZW50c1Jlc3BvbnNlEhUKCGV2ZW50X2lkGAEgASgJQgPgQQISGQoHcGF5bG9hZBgCIAEoDEID4EEBSACIAQESNwoJdGltZXN0YW1wGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEBSAGIAQESLAoHcHJvZ3JhbRgEIAEoCzIWLnRocnUuY29tbW9uLnYxLlB1YmtleUID4EECEhUKCGNhbGxfaWR4GAUgASgNQgPgQQISMQoJc2lnbmF0dXJlGAYgASgLMhkudGhydS5jb21tb24udjEuU2lnbmF0dXJlQgPgQQISEQoEc2xvdBgHIAEoBEID4EECQgoKCF9wYXlsb2FkQgwKCl90aW1lc3RhbXAijgEKF1RyYWNrVHJhbnNhY3Rpb25SZXF1ZXN0EjEKCXNpZ25hdHVyZRgBIAEoCzIZLnRocnUuY29tbW9uLnYxLlNpZ25hdHVyZUID4EECEjQKB3RpbWVvdXQYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBAUgAiAEBQgoKCF90aW1lb3V0ItYBChhUcmFja1RyYW5zYWN0aW9uUmVzcG9uc2USMQoJc2lnbmF0dXJlGAEgASgLMhkudGhydS5jb21tb24udjEuU2lnbmF0dXJlQgPgQQISPgoQY29uc2Vuc3VzX3N0YXR1cxgCIAEoDjIfLnRocnUuY29tbW9uLnYxLkNvbnNlbnN1c1N0YXR1c0ID4EEBEkcKEGV4ZWN1dGlvbl9yZXN1bHQYAyABKAsyKC50aHJ1LmNvcmUudjEuVHJhbnNhY3Rpb25FeGVjdXRpb25SZXN1bHRCA+BBASJHChhTdHJlYW1TbG90TWV0cmljc1JlcXVlc3QSHAoKc3RhcnRfc2xvdBgBIAEoBEID4EEBSACIAQFCDQoLX3N0YXJ0X3Nsb3Qi+gEKGVN0cmVhbVNsb3RNZXRyaWNzUmVzcG9uc2USEQoEc2xvdBgBIAEoBEID4EECEisKHmdsb2JhbF9hY3RpdmF0ZWRfc3RhdGVfY291bnRlchgCIAEoBEID4EECEi0KIGdsb2JhbF9kZWFjdGl2YXRlZF9zdGF0ZV9jb3VudGVyGAMgASgEQgPgQQISGwoOY29sbGVjdGVkX2ZlZXMYBCABKARCA+BBAhI9Cg9ibG9ja190aW1lc3RhbXAYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQFIAIgBAUISChBfYmxvY2tfdGltZXN0YW1wIhUKE1N0cmVhbUhlaWdodFJlcXVlc3QibAoUU3RyZWFtSGVpZ2h0UmVzcG9uc2USFgoJZmluYWxpemVkGAEgASgEQgPgQQISHQoQbG9jYWxseV9leGVjdXRlZBgCIAEoBEID4EECEh0KEGNsdXN0ZXJfZXhlY3V0ZWQYAyABKARCA+BBAjL+BQoQU3RyZWFtaW5nU2VydmljZRJfCgxTdHJlYW1CbG9ja3MSJS50aHJ1LnNlcnZpY2VzLnYxLlN0cmVhbUJsb2Nrc1JlcXVlc3QaJi50aHJ1LnNlcnZpY2VzLnYxLlN0cmVhbUJsb2Nrc1Jlc3BvbnNlMAESdwoUU3RyZWFtQWNjb3VudFVwZGF0ZXMSLS50aHJ1LnNlcnZpY2VzLnYxLlN0cmVhbUFjY291bnRVcGRhdGVzUmVxdWVzdBouLnRocnUuc2VydmljZXMudjEuU3RyZWFtQWNjb3VudFVwZGF0ZXNSZXNwb25zZTABEnEKElN0cmVhbVRyYW5zYWN0aW9ucxIrLnRocnUuc2VydmljZXMudjEuU3RyZWFtVHJhbnNhY3Rpb25zUmVxdWVzdBosLnRocnUuc2VydmljZXMudjEuU3RyZWFtVHJhbnNhY3Rpb25zUmVzcG9uc2UwARJfCgxTdHJlYW1FdmVudHMSJS50aHJ1LnNlcnZpY2VzLnYxLlN0cmVhbUV2ZW50c1JlcXVlc3QaJi50aHJ1LnNlcnZpY2VzLnYxLlN0cmVhbUV2ZW50c1Jlc3BvbnNlMAESawoQVHJhY2tUcmFuc2FjdGlvbhIpLnRocnUuc2VydmljZXMudjEuVHJhY2tUcmFuc2FjdGlvblJlcXVlc3QaKi50aHJ1LnNlcnZpY2VzLnYxLlRyYWNrVHJhbnNhY3Rpb25SZXNwb25zZTABEl8KDFN0cmVhbUhlaWdodBIlLnRocnUuc2VydmljZXMudjEuU3RyZWFtSGVpZ2h0UmVxdWVzdBomLnRocnUuc2VydmljZXMudjEuU3RyZWFtSGVpZ2h0UmVzcG9uc2UwARJuChFTdHJlYW1TbG90TWV0cmljcxIqLnRocnUuc2VydmljZXMudjEuU3RyZWFtU2xvdE1ldHJpY3NSZXF1ZXN0GisudGhydS5zZXJ2aWNlcy52MS5TdHJlYW1TbG90TWV0cmljc1Jlc3BvbnNlMAFC4AEKFGNvbS50aHJ1LnNlcnZpY2VzLnYxQhVTdHJlYW1pbmdTZXJ2aWNlUHJvdG9QAVpIZ2l0aHViLmNvbS9VbnRvLUxhYnMvdGhydS1uZXQvZ3JwYy9wa2cvcHJvdG8vdGhydS9zZXJ2aWNlcy92MTtzZXJ2aWNlc3YxogIDVFNYqgIQVGhydS5TZXJ2aWNlcy5WMboCBFRIVVPKAhBUaHJ1XFNlcnZpY2VzXFYx4gIcVGhydVxTZXJ2aWNlc1xWMVxHUEJNZXRhZGF0YeoCElRocnU6OlNlcnZpY2VzOjpWMWIGcHJvdG8z", [file_buf_validate_validate, file_google_api_field_behavior, file_thru_common_v1_primitives, file_google_protobuf_duration, file_google_protobuf_timestamp, file_thru_common_v1_consensus, file_thru_common_v1_filters, file_thru_core_v1_account, file_thru_core_v1_block, file_thru_core_v1_transaction, file_thru_core_v1_types]);

/**
 * StreamBlocksRequest subscribes to real-time block updates.
 *
 * Filter expressions support the following params:
 *
 * - params.slot (int64): Slot number for comparison
 *   Example: block.block.header.slot == params.slot
 *
 * - params.min_slot (int64): Minimum slot for range filtering
 *   Example: block.block.header.slot >= params.min_slot
 *
 * - params.start_slot (int64): Starting slot for filtering
 *   Example: block.block.header.slot >= params.start_slot
 *
 * - params.u64 (int64): Generic 64-bit value for numeric comparisons
 *   Examples:
 *     block.block.header.max_compute_units > params.u64
 *     block.block.header.bond_amount_lock_up >= params.u64
 *
 * - params.producer (bytes|Pubkey): Producer pubkey for filtering
 *   Examples:
 *     block.block.header.producer.value == params.producer
 *     has(block.block.header.producer) && block.block.header.producer.value == params.producer
 *
 * Available block header fields:
 *   block.block.header.slot, block.block.header.version,
 *   block.block.header.start_slot, block.block.header.expiry_after,
 *   block.block.header.max_block_size, block.block.header.max_compute_units,
 *   block.block.header.max_state_units, block.block.header.bond_amount_lock_up,
 *   block.block.header.producer, block.block.header.producer.value
 *
 * Available block footer fields:
 *   block.block.footer.status, block.block.footer.consumed_compute_units,
 *   block.block.footer.consumed_state_units, block.block.footer.attestor_payment
 *
 * Available consensus status field:
 *   block.block.consensus_status
 *
 * Filter expression examples:
 *
 * 1. Filter by specific slot:
 *    Expression: "block.block.header.slot == params.slot"
 *    Params: {"slot": 12345}
 *
 * 2. Filter by slot range:
 *    Expression: "block.block.header.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 3. Filter by block version:
 *    Expression: "block.block.header.version >= uint(0)"
 *
 * 4. Filter by specific producer:
 *    Expression: "has(block.block.header.producer) && block.block.header.producer.value == params.producer"
 *    Params: {"producer": <32-byte pubkey>}
 *
 * 5. Filter by max compute units:
 *    Expression: "block.block.header.max_compute_units > uint(0)"
 *
 * 6. Filter by max state units:
 *    Expression: "block.block.header.max_state_units > uint(0)"
 *
 * 7. Filter by bond amount lock-up:
 *    Expression: "block.block.header.bond_amount_lock_up >= uint(0)"
 *
 * 8. Filter by footer status:
 *    Expression: "has(block.block.footer) && block.block.footer.status == int(1)"
 *    Note: EXECUTION_STATUS_PENDING = 1, EXECUTION_STATUS_EXECUTED = 2
 *
 * 9. Filter by consumed compute units:
 *    Expression: "has(block.block.footer) && block.block.footer.consumed_compute_units > uint(0)"
 *
 * 10. Filter by consumed state units:
 *     Expression: "has(block.block.footer) && block.block.footer.consumed_state_units > uint(0)"
 *
 * 11. Filter by consensus status:
 *     Expression: "block.block.consensus_status == int(2)"
 *     Note: CONSENSUS_STATUS_UNSPECIFIED = 0, CONSENSUS_STATUS_OBSERVED = 1,
 *           CONSENSUS_STATUS_INCLUDED = 2
 *
 * 12. Check for optional fields presence:
 *     Expression: "has(block.block.header) && has(block.block.footer)"
 *
 * 13. Combined filters (multiple conditions):
 *     Expression: "block.block.header.slot >= params.min_slot && has(block.block.footer) && block.block.footer.consumed_compute_units > uint(0)"
 *     Params: {"min_slot": 1000}
 *
 * 14. Numeric comparison with params:
 *     Expression: "block.block.header.max_compute_units > params.u64"
 *     Params: {"u64": 1000000}
 *
 * @generated from message thru.services.v1.StreamBlocksRequest
 */
export type StreamBlocksRequest = Message<"thru.services.v1.StreamBlocksRequest"> & {
  /**
   * @generated from field: optional uint64 start_slot = 1;
   */
  startSlot?: bigint;

  /**
   * @generated from field: optional thru.common.v1.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.core.v1.BlockView view = 3;
   */
  view?: BlockView;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;
};

/**
 * Describes the message thru.services.v1.StreamBlocksRequest.
 * Use `create(StreamBlocksRequestSchema)` to create a new message.
 */
export const StreamBlocksRequestSchema: GenMessage<StreamBlocksRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 0);

/**
 * StreamBlocksResponse delivers block updates.
 *
 * @generated from message thru.services.v1.StreamBlocksResponse
 */
export type StreamBlocksResponse = Message<"thru.services.v1.StreamBlocksResponse"> & {
  /**
   * @generated from field: thru.core.v1.Block block = 1;
   */
  block?: Block;
};

/**
 * Describes the message thru.services.v1.StreamBlocksResponse.
 * Use `create(StreamBlocksResponseSchema)` to create a new message.
 */
export const StreamBlocksResponseSchema: GenMessage<StreamBlocksResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 1);

/**
 * StreamAccountUpdatesRequest subscribes to account delta events.
 *
 * Filter expressions support the following params:
 *
 * - params.min_slot (uint64): Minimum slot for filtering updates
 *   Example: account_update.slot >= params.min_slot
 *
 * - params.min_balance (uint64): Minimum balance for filtering
 *   Example: snapshot.meta.balance >= params.min_balance
 *
 * - params.owner (bytes|Pubkey): Owner pubkey for filtering
 *   Examples:
 *     snapshot.meta.owner.value == params.owner
 *     account_update.meta.owner.value == params.owner
 *
 * - params.address (bytes|Pubkey): Account address for filtering
 *   Example: account_address.value == params.address
 *   Note: Use account_address for unified filtering across both snapshot and update messages
 *
 * - params.addresses (BytesList): List of addresses for multi-account filtering
 *   Example: account_address.value in params.addresses
 *   Note: Use the 'in' operator to filter by multiple addresses in a single subscription
 *
 * - params.min_nonce (uint64): Minimum nonce for filtering
 *   Example: snapshot.meta.nonce >= params.min_nonce
 *
 * - params.min_seq (uint64): Minimum sequence number for filtering
 *   Example: snapshot.meta.seq >= params.min_seq
 *
 * - params.min_data_size (uint32): Minimum data size for filtering
 *   Example: snapshot.meta.data_size >= params.min_data_size
 *
 * Available snapshot fields (thru.core.v1.Account):
 *   snapshot.address, snapshot.address.value (bytes),
 *   snapshot.meta.balance (uint64), snapshot.meta.seq (uint64),
 *   snapshot.meta.nonce (uint64), snapshot.meta.data_size (uint32),
 *   snapshot.meta.version (uint32), snapshot.meta.flags (AccountFlags),
 *   snapshot.meta.flags.is_program (bool), snapshot.meta.flags.is_privileged (bool),
 *   snapshot.meta.flags.is_uncompressable (bool), snapshot.meta.flags.is_ephemeral (bool),
 *   snapshot.meta.flags.is_deleted (bool), snapshot.meta.flags.is_new (bool),
 *   snapshot.meta.flags.is_compressed (bool),
 *   snapshot.meta.owner, snapshot.meta.owner.value (bytes)
 *
 * Available account_update fields (AccountUpdate):
 *   account_update.slot (uint64), account_update.delete (bool),
 *   account_update.meta.balance (uint64), account_update.meta.seq (uint64),
 *   account_update.meta.nonce (uint64), account_update.meta.data_size (uint32),
 *   account_update.meta.version (uint32), account_update.meta.flags (AccountFlags),
 *   account_update.meta.flags.is_program (bool), account_update.meta.flags.is_privileged (bool),
 *   account_update.meta.flags.is_uncompressable (bool), account_update.meta.flags.is_ephemeral (bool),
 *   account_update.meta.flags.is_deleted (bool), account_update.meta.flags.is_new (bool),
 *   account_update.meta.flags.is_compressed (bool),
 *   account_update.meta.owner, account_update.meta.owner.value (bytes)
 *
 * Available unified fields (work for both snapshot and update messages):
 *   account_address, account_address.value (bytes) - extracted from whichever message type is present
 *
 * Filter expression examples:
 *
 * 1. Filter by minimum balance (snapshot or update):
 *    Expression: "(has(snapshot.meta) && snapshot.meta.balance >= uint(1000000)) || (has(account_update.meta) && account_update.meta.balance >= uint(1000000))"
 *
 * 2. Filter by account owner using params:
 *    Expression: "(has(snapshot.meta) && has(snapshot.meta.owner) && snapshot.meta.owner.value == params.owner) || (has(account_update.meta) && has(account_update.meta.owner) && account_update.meta.owner.value == params.owner)"
 *    Params: {"owner": <32-byte pubkey>}
 *
 * 3. Filter by specific account address (works for both snapshot and update messages):
 *    Expression: "account_address.value == params.address"
 *    Params: {"address": <32-byte pubkey>}
 *
 * 4. Filter by minimum slot for updates:
 *    Expression: "has(account_update.meta) && account_update.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 5. Filter by nonce greater than value:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.nonce >= uint(5)) || (has(account_update.meta) && account_update.meta.nonce >= uint(5))"
 *
 * 6. Filter by sequence number:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.seq >= uint(100)) || (has(account_update.meta) && account_update.meta.seq >= uint(100))"
 *
 * 7. Filter by data size:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.data_size >= uint(1024)) || (has(account_update.meta) && account_update.meta.data_size >= uint(1024))"
 *
 * 8. Filter by account version:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.version >= uint(1)) || (has(account_update.meta) && account_update.meta.version >= uint(1))"
 *
 * 9. Filter by account flags (check if account is a program):
 *    Expression: "(has(snapshot.meta) && has(snapshot.meta.flags) && snapshot.meta.flags.is_program) || (has(account_update.meta) && has(account_update.meta.flags) && account_update.meta.flags.is_program)"
 *
 * 10. Filter by privileged flag:
 *     Expression: "(has(snapshot.meta) && has(snapshot.meta.flags) && snapshot.meta.flags.is_privileged) || (has(account_update.meta) && has(account_update.meta.flags) && account_update.meta.flags.is_privileged)"
 *
 * 11. Filter non-delete updates:
 *     Expression: "has(snapshot.meta) || (has(account_update.meta) && (!has(account_update.delete) || !account_update.delete))"
 *
 * 12. Check for snapshot or update presence:
 *     Expression: "has(snapshot.meta) || has(account_update.meta)"
 *
 * 13. Combined filters (multiple conditions):
 *     Expression: "has(snapshot.meta) || (has(account_update.meta) && account_update.slot >= params.min_slot && account_update.meta.balance >= params.min_balance)"
 *     Params: {"min_slot": 1000, "min_balance": 1000000}
 *
 * 14. Filter by minimum balance using params:
 *     Expression: "(has(snapshot.meta) && snapshot.meta.balance >= params.min_balance) || (has(account_update.meta) && account_update.meta.balance >= params.min_balance)"
 *     Params: {"min_balance": 5000000000}
 *
 * Note: The response contains either a snapshot (initial state), an update (delta),
 * or a BlockFinished message. Filters should handle both snapshot and update cases
 * using OR logic to match either message type.
 *
 * To filter by specific account address (recommended - works for both message types):
 *   Expression: "account_address.value == params.address"
 *   Params: {"address": <32-byte pubkey>}
 *
 * To filter by owner (program):
 *   Expression: "(has(snapshot.meta.owner) && snapshot.meta.owner.value == params.owner) || (has(account_update.meta.owner) && account_update.meta.owner.value == params.owner)"
 *   Params: {"owner": <32-byte program pubkey>}
 *
 * To filter by multiple account addresses (recommended for multi-account subscriptions):
 *   Expression: "account_address.value in params.addresses"
 *   Params: {"addresses": BytesList{values: [<pubkey1>, <pubkey2>, ...]}}
 *   Note: Use BytesList parameter type with the 'in' operator for efficient multi-address filtering
 *
 * @generated from message thru.services.v1.StreamAccountUpdatesRequest
 */
export type StreamAccountUpdatesRequest = Message<"thru.services.v1.StreamAccountUpdatesRequest"> & {
  /**
   * @generated from field: optional thru.core.v1.AccountView view = 2;
   */
  view?: AccountView;

  /**
   * @generated from field: optional thru.common.v1.Filter filter = 4;
   */
  filter?: Filter;
};

/**
 * Describes the message thru.services.v1.StreamAccountUpdatesRequest.
 * Use `create(StreamAccountUpdatesRequestSchema)` to create a new message.
 */
export const StreamAccountUpdatesRequestSchema: GenMessage<StreamAccountUpdatesRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 2);

/**
 * AccountUpdate describes a delta for an account.
 *
 * @generated from message thru.services.v1.AccountUpdate
 */
export type AccountUpdate = Message<"thru.services.v1.AccountUpdate"> & {
  /**
   * @generated from field: uint64 slot = 1;
   */
  slot: bigint;

  /**
   * @generated from field: optional thru.core.v1.AccountPage page = 2;
   */
  page?: AccountPage;

  /**
   * @generated from field: optional thru.core.v1.AccountMeta meta = 3;
   */
  meta?: AccountMeta;

  /**
   * @generated from field: optional bool delete = 4;
   */
  delete?: boolean;

  /**
   * Account address for identifying the account in multi-account streams.
   *
   * @generated from field: thru.common.v1.Pubkey address = 5;
   */
  address?: Pubkey;
};

/**
 * Describes the message thru.services.v1.AccountUpdate.
 * Use `create(AccountUpdateSchema)` to create a new message.
 */
export const AccountUpdateSchema: GenMessage<AccountUpdate> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 3);

/**
 * BlockFinished is sent when block's execution is complete.
 * Contains block accumulator metrics finalized after execution.
 *
 * @generated from message thru.services.v1.BlockFinished
 */
export type BlockFinished = Message<"thru.services.v1.BlockFinished"> & {
  /**
   * @generated from field: uint64 slot = 1;
   */
  slot: bigint;

  /**
   * Global counter tracking total activated state across all accounts.
   * Increments when accounts are created or modified.
   *
   * @generated from field: uint64 global_activated_state_counter = 2;
   */
  globalActivatedStateCounter: bigint;

  /**
   * Global counter tracking total deactivated state across all accounts.
   * Increments when accounts are deleted or compressed.
   *
   * @generated from field: uint64 global_deactivated_state_counter = 3;
   */
  globalDeactivatedStateCounter: bigint;

  /**
   * Total fees collected from all transactions in this block.
   *
   * @generated from field: uint64 collected_fees = 4;
   */
  collectedFees: bigint;
};

/**
 * Describes the message thru.services.v1.BlockFinished.
 * Use `create(BlockFinishedSchema)` to create a new message.
 */
export const BlockFinishedSchema: GenMessage<BlockFinished> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 4);

/**
 * StreamAccountUpdatesResponse contains either an initial snapshot or a delta.
 *
 * @generated from message thru.services.v1.StreamAccountUpdatesResponse
 */
export type StreamAccountUpdatesResponse = Message<"thru.services.v1.StreamAccountUpdatesResponse"> & {
  /**
   * @generated from oneof thru.services.v1.StreamAccountUpdatesResponse.message
   */
  message: {
    /**
     * @generated from field: thru.core.v1.Account snapshot = 1;
     */
    value: Account;
    case: "snapshot";
  } | {
    /**
     * @generated from field: thru.services.v1.AccountUpdate update = 2;
     */
    value: AccountUpdate;
    case: "update";
  } | {
    /**
     * @generated from field: thru.services.v1.BlockFinished finished = 3;
     */
    value: BlockFinished;
    case: "finished";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message thru.services.v1.StreamAccountUpdatesResponse.
 * Use `create(StreamAccountUpdatesResponseSchema)` to create a new message.
 */
export const StreamAccountUpdatesResponseSchema: GenMessage<StreamAccountUpdatesResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 5);

/**
 * StreamTransactionsRequest subscribes to transaction confirmations.
 *
 * Filter expressions support the following params:
 *
 * - params.min_slot (uint64): Minimum slot for filtering transactions
 *   Example: transaction.slot >= params.min_slot
 *
 * - params.max_slot (uint64): Maximum slot for filtering transactions
 *   Example: transaction.slot <= params.max_slot
 *
 * - params.slot (uint64): Specific slot for exact match filtering
 *   Example: transaction.slot == params.slot
 *
 * - params.min_fee (uint64): Minimum fee for filtering transactions
 *   Example: transaction.header.fee >= params.min_fee
 *
 * - params.fee_payer (bytes|Pubkey): Fee payer pubkey for filtering
 *   Example: transaction.header.fee_payer_pubkey.value == params.fee_payer
 *
 * - params.signature (bytes|Signature): Transaction signature for filtering
 *   Example: transaction.signature.value == params.signature
 *
 * Available transaction fields (thru.core.v1.Transaction):
 *   transaction.signature, transaction.signature.value (bytes),
 *   transaction.slot (uint64), transaction.block_offset (uint32),
 *   transaction.header, transaction.header.version (uint32),
 *   transaction.header.fee (uint64),
 *   transaction.header.fee_payer_pubkey, transaction.header.fee_payer_pubkey.value (bytes),
 *   transaction.execution_result, transaction.execution_result.user_error_code (uint32),
 *   transaction.execution_result.vm_error (int32)
 *
 * Available consensus_status field:
 *   consensus_status (int32) - Current consensus status of the transaction
 *   Values: CONSENSUS_STATUS_UNSPECIFIED = 0, CONSENSUS_STATUS_OBSERVED = 1,
 *           CONSENSUS_STATUS_INCLUDED = 2
 *
 * Filter expression examples:
 *
 * 1. Filter by minimum slot:
 *    Expression: "has(transaction.slot) && transaction.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 2. Filter by slot range:
 *    Expression: "has(transaction.slot) && transaction.slot >= params.min_slot && transaction.slot <= params.max_slot"
 *    Params: {"min_slot": 1000, "max_slot": 2000}
 *
 * 3. Filter by specific slot:
 *    Expression: "has(transaction.slot) && transaction.slot == params.slot"
 *    Params: {"slot": 12345}
 *
 * 4. Filter by minimum fee:
 *    Expression: "has(transaction.header) && transaction.header.fee >= params.min_fee"
 *    Params: {"min_fee": 5000}
 *
 * 5. Filter by fee payer:
 *    Expression: "has(transaction.header.fee_payer_pubkey) && transaction.header.fee_payer_pubkey.value == params.fee_payer"
 *    Params: {"fee_payer": <32-byte pubkey>}
 *
 * 6. Filter by transaction signature:
 *    Expression: "has(transaction.signature) && transaction.signature.value == params.signature"
 *    Params: {"signature": <64-byte signature>}
 *
 * 7. Filter by header version:
 *    Expression: "has(transaction.header) && transaction.header.version >= uint(0)"
 *
 * 8. Filter by successful execution:
 *    Expression: "has(transaction.execution_result) && transaction.execution_result.vm_error == int(0)"
 *
 * 9. Filter by user error code:
 *    Expression: "has(transaction.execution_result) && transaction.execution_result.user_error_code == uint(0)"
 *
 * 10. Filter by consensus status:
 *     Expression: "consensus_status >= int(2)"
 *     Note: Use >= int(2) for CONSENSUS_STATUS_INCLUDED and above
 *
 * 11. Check for execution result presence:
 *     Expression: "has(transaction.execution_result)"
 *
 * 12. Filter by transaction with header and slot:
 *     Expression: "has(transaction.slot) && transaction.slot >= uint(0) && has(transaction.header)"
 *
 * 13. Combined filters (slot, fee, and status):
 *     Expression: "has(transaction.slot) && transaction.slot >= params.min_slot && has(transaction.header) && transaction.header.fee >= params.min_fee && consensus_status >= int(2)"
 *     Params: {"min_slot": 1000, "min_fee": 5000}
 *
 * 14. Filter successful transactions with minimum fee:
 *     Expression: "has(transaction.execution_result) && transaction.execution_result.vm_error == int(0) && has(transaction.header) && transaction.header.fee >= params.min_fee"
 *     Params: {"min_fee": 10000}
 *
 * Note: The min_consensus field in the request provides built-in consensus filtering
 * without requiring a CEL expression. Use it in combination with filter expressions
 * for more complex filtering logic.
 *
 * @generated from message thru.services.v1.StreamTransactionsRequest
 */
export type StreamTransactionsRequest = Message<"thru.services.v1.StreamTransactionsRequest"> & {
  /**
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 2;
   */
  minConsensus?: ConsensusStatus;
};

/**
 * Describes the message thru.services.v1.StreamTransactionsRequest.
 * Use `create(StreamTransactionsRequestSchema)` to create a new message.
 */
export const StreamTransactionsRequestSchema: GenMessage<StreamTransactionsRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 6);

/**
 * StreamTransactionsResponse delivers transaction events.
 *
 * @generated from message thru.services.v1.StreamTransactionsResponse
 */
export type StreamTransactionsResponse = Message<"thru.services.v1.StreamTransactionsResponse"> & {
  /**
   * @generated from field: thru.core.v1.Transaction transaction = 1;
   */
  transaction?: Transaction;
};

/**
 * Describes the message thru.services.v1.StreamTransactionsResponse.
 * Use `create(StreamTransactionsResponseSchema)` to create a new message.
 */
export const StreamTransactionsResponseSchema: GenMessage<StreamTransactionsResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 7);

/**
 * StreamEventsRequest subscribes to chain events.
 *
 * Filter expressions support the following params:
 *
 * - params.prefix (bytes): Byte prefix for payload filtering
 *   Example: bytesPrefix(event.payload, params.prefix)
 *
 * - params.slot (int64): Slot number for comparison
 *   Example: event.slot >= params.slot
 *
 * - params.u64 (int64): Generic 64-bit value for payload extraction
 *   Examples:
 *     first8Bytes(event.payload) == params.u64
 *     first4Bytes(event.payload) == params.u64
 *     first1Byte(event.payload) == params.u64
 *
 * - params.signature (bytes|Signature|TsSignature): Signature for comparison
 *   Examples:
 *     event.signature.value == params.signature        // bytes type
 *     bytesPrefix(event.signature.value, params.signature)
 *   Note: Signature and TsSignature types are auto-converted to bytes
 *
 * - params.address (bytes|Pubkey|TaPubkey): Address/pubkey for comparison
 *   Examples:
 *     event.program.value == params.address            // bytes type
 *     bytesPrefix(event.program.value, params.address)
 *   Note: Pubkey and TaPubkey types are auto-converted to bytes
 *
 * - params.timestamp (int64): Timestamp in seconds for comparison
 *   Example: int(event.timestamp) > params.timestamp
 *
 * Available event fields:
 *   event.event_id (string), event.slot (uint64), event.payload (bytes),
 *   event.call_idx (uint32), event.signature (Signature),
 *   event.signature.value (bytes), event.program (Pubkey),
 *   event.program.value (bytes), event.timestamp (Timestamp)
 *
 * Note: Unlike ListEventsRequest in QueryService, StreamEventsRequest does NOT support:
 *   event.block_offset, event.program_idx, event.payload_size, event.transaction_signature
 *
 * Available filter functions:
 *   - has(field): Check if optional field exists
 *     Example: has(event.program) && has(event.signature)
 *
 *   - startsWith(string, prefix): Check if string starts with prefix
 *     Example: event.event_id.startsWith("ts")
 *
 *   - bytesPrefix(bytes, prefix): Check if bytes start with prefix
 *     Examples:
 *       bytesPrefix(event.payload, b"\x01\x00\x00\x00\x00\x00\x00\x00")
 *       bytesPrefix(event.payload, params.prefix)
 *       bytesPrefix(event.program.value, params.address)
 *       bytesPrefix(event.signature.value, params.signature)
 *
 *   - first1Byte(bytes): Extract first byte as uint
 *     Example: first1Byte(event.payload) == uint(1)
 *
 *   - first4Bytes(bytes): Extract first 4 bytes as little-endian uint32
 *     Example: first4Bytes(event.payload) == uint(2)
 *
 *   - first8Bytes(bytes): Extract first 8 bytes as little-endian uint64
 *     Example: first8Bytes(event.payload) == uint(6)
 *
 *   - uint(value): Convert value to uint for comparison
 *   - int(value): Convert value to int (used for timestamps)
 *
 * Filter expression examples:
 *
 * 1. Filter by payload type using first1Byte (MESSAGE event type = 1):
 *    Expression: "first1Byte(event.payload) == uint(1)"
 *
 * 2. Filter by payload type using first4Bytes (COUNTER event type = 2):
 *    Expression: "first4Bytes(event.payload) == uint(2)"
 *
 * 3. Filter by payload type using first8Bytes (PATTERN event type = 6):
 *    Expression: "first8Bytes(event.payload) == uint(6)"
 *
 * 4. Filter by payload prefix with params:
 *    Expression: "bytesPrefix(event.payload, params.prefix)"
 *    Params: {"prefix": <bytes, e.g., 0x01000000...>}
 *
 * 5. Filter by slot using params:
 *    Expression: "event.slot >= params.slot"
 *    Params: {"slot": 1000}
 *
 * 6. Filter by program address (exact match):
 *    Expression: "event.program.value == params.address"
 *    Params: {"address": <32-byte pubkey as bytes, Pubkey, or TaPubkey>}
 *
 * 7. Filter by program address (prefix match):
 *    Expression: "bytesPrefix(event.program.value, params.address)"
 *    Params: {"address": <pubkey prefix bytes>}
 *
 * 8. Filter by transaction signature (exact match):
 *    Expression: "event.signature.value == params.signature"
 *    Params: {"signature": <64-byte signature as bytes, Signature, or TsSignature>}
 *
 * 9. Filter by transaction signature (prefix match):
 *    Expression: "bytesPrefix(event.signature.value, params.signature)"
 *    Params: {"signature": <signature prefix bytes>}
 *
 * 10. Filter by call_idx (0 = main program, 1+ = CPI calls):
 *     Expression: "event.call_idx == uint(0)"
 *     Expression: "event.call_idx == uint(1)"
 *
 * 11. Filter by event_id prefix:
 *     Expression: "event.event_id.startsWith(\"ts\")"
 *
 * 12. Filter by timestamp (events in last hour):
 *     Expression: "has(event.timestamp) && int(event.timestamp) > int(1700000000)"
 *
 * 13. Filter by timestamp using params:
 *     Expression: "has(event.timestamp) && int(event.timestamp) > params.timestamp"
 *     Params: {"timestamp": 1700000000}
 *
 * 14. Check field existence:
 *     Expression: "has(event.program) && has(event.signature)"
 *
 * 15. Filter using params.u64 with first8Bytes:
 *     Expression: "first8Bytes(event.payload) == params.u64"
 *     Params: {"u64": 6}
 *
 * 16. Filter using params.u64 with first4Bytes:
 *     Expression: "first4Bytes(event.payload) == params.u64"
 *     Params: {"u64": 2}
 *
 * 17. Filter using params.u64 with first1Byte:
 *     Expression: "first1Byte(event.payload) == params.u64"
 *     Params: {"u64": 1}
 *
 * 18. Combined filter (slot + payload type + call_idx):
 *     Expression: "event.slot > uint(1000) && first1Byte(event.payload) == uint(1) && event.call_idx == uint(0)"
 *
 * 19. Combined filter (call_idx + program address):
 *     Expression: "event.call_idx == uint(1) && event.program.value == params.address"
 *     Params: {"address": <32-byte CPI target program pubkey>}
 *
 * 20. Timestamp range filter:
 *     Expression: "has(event.timestamp) && int(event.timestamp) > int(1700000000) && int(event.timestamp) < int(1700100000)"
 *
 * @generated from message thru.services.v1.StreamEventsRequest
 */
export type StreamEventsRequest = Message<"thru.services.v1.StreamEventsRequest"> & {
  /**
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;
};

/**
 * Describes the message thru.services.v1.StreamEventsRequest.
 * Use `create(StreamEventsRequestSchema)` to create a new message.
 */
export const StreamEventsRequestSchema: GenMessage<StreamEventsRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 8);

/**
 * StreamEventsResponse delivers event payloads.
 *
 * @generated from message thru.services.v1.StreamEventsResponse
 */
export type StreamEventsResponse = Message<"thru.services.v1.StreamEventsResponse"> & {
  /**
   * @generated from field: string event_id = 1;
   */
  eventId: string;

  /**
   * @generated from field: optional bytes payload = 2;
   */
  payload?: Uint8Array;

  /**
   * @generated from field: optional google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: thru.common.v1.Pubkey program = 4;
   */
  program?: Pubkey;

  /**
   * @generated from field: uint32 call_idx = 5;
   */
  callIdx: number;

  /**
   * @generated from field: thru.common.v1.Signature signature = 6;
   */
  signature?: Signature;

  /**
   * @generated from field: uint64 slot = 7;
   */
  slot: bigint;
};

/**
 * Describes the message thru.services.v1.StreamEventsResponse.
 * Use `create(StreamEventsResponseSchema)` to create a new message.
 */
export const StreamEventsResponseSchema: GenMessage<StreamEventsResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 9);

/**
 * TrackTransactionRequest subscribes to status updates for a transaction.
 *
 * @generated from message thru.services.v1.TrackTransactionRequest
 */
export type TrackTransactionRequest = Message<"thru.services.v1.TrackTransactionRequest"> & {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: optional google.protobuf.Duration timeout = 2;
   */
  timeout?: Duration;
};

/**
 * Describes the message thru.services.v1.TrackTransactionRequest.
 * Use `create(TrackTransactionRequestSchema)` to create a new message.
 */
export const TrackTransactionRequestSchema: GenMessage<TrackTransactionRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 10);

/**
 * TrackTransactionResponse reports status transitions for a transaction.
 *
 * @generated from message thru.services.v1.TrackTransactionResponse
 */
export type TrackTransactionResponse = Message<"thru.services.v1.TrackTransactionResponse"> & {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: thru.common.v1.ConsensusStatus consensus_status = 2;
   */
  consensusStatus: ConsensusStatus;

  /**
   * @generated from field: thru.core.v1.TransactionExecutionResult execution_result = 3;
   */
  executionResult?: TransactionExecutionResult;
};

/**
 * Describes the message thru.services.v1.TrackTransactionResponse.
 * Use `create(TrackTransactionResponseSchema)` to create a new message.
 */
export const TrackTransactionResponseSchema: GenMessage<TrackTransactionResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 11);

/**
 * StreamSlotMetricsRequest subscribes to per-slot metrics updates.
 * Metrics are emitted after each block's execution completes.
 *
 * @generated from message thru.services.v1.StreamSlotMetricsRequest
 */
export type StreamSlotMetricsRequest = Message<"thru.services.v1.StreamSlotMetricsRequest"> & {
  /**
   * Optional starting slot. If specified, starts streaming from this slot.
   * If not specified, starts from the next executed slot.
   *
   * @generated from field: optional uint64 start_slot = 1;
   */
  startSlot?: bigint;
};

/**
 * Describes the message thru.services.v1.StreamSlotMetricsRequest.
 * Use `create(StreamSlotMetricsRequestSchema)` to create a new message.
 */
export const StreamSlotMetricsRequestSchema: GenMessage<StreamSlotMetricsRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 12);

/**
 * StreamSlotMetricsResponse delivers slot metrics after execution completes.
 *
 * @generated from message thru.services.v1.StreamSlotMetricsResponse
 */
export type StreamSlotMetricsResponse = Message<"thru.services.v1.StreamSlotMetricsResponse"> & {
  /**
   * Block slot number.
   *
   * @generated from field: uint64 slot = 1;
   */
  slot: bigint;

  /**
   * Global counter tracking total activated state across all accounts.
   *
   * @generated from field: uint64 global_activated_state_counter = 2;
   */
  globalActivatedStateCounter: bigint;

  /**
   * Global counter tracking total deactivated state across all accounts.
   *
   * @generated from field: uint64 global_deactivated_state_counter = 3;
   */
  globalDeactivatedStateCounter: bigint;

  /**
   * Total fees collected from all transactions in this block.
   *
   * @generated from field: uint64 collected_fees = 4;
   */
  collectedFees: bigint;

  /**
   * Block timestamp when available.
   *
   * @generated from field: optional google.protobuf.Timestamp block_timestamp = 5;
   */
  blockTimestamp?: Timestamp;
};

/**
 * Describes the message thru.services.v1.StreamSlotMetricsResponse.
 * Use `create(StreamSlotMetricsResponseSchema)` to create a new message.
 */
export const StreamSlotMetricsResponseSchema: GenMessage<StreamSlotMetricsResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 13);

/**
 * StreamHeightRequest subscribes to real-time height updates.
 *
 * @generated from message thru.services.v1.StreamHeightRequest
 */
export type StreamHeightRequest = Message<"thru.services.v1.StreamHeightRequest"> & {
};

/**
 * Describes the message thru.services.v1.StreamHeightRequest.
 * Use `create(StreamHeightRequestSchema)` to create a new message.
 */
export const StreamHeightRequestSchema: GenMessage<StreamHeightRequest> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 14);

/**
 * StreamHeightResponse delivers height update events.
 *
 * @generated from message thru.services.v1.StreamHeightResponse
 */
export type StreamHeightResponse = Message<"thru.services.v1.StreamHeightResponse"> & {
  /**
   * @generated from field: uint64 finalized = 1;
   */
  finalized: bigint;

  /**
   * @generated from field: uint64 locally_executed = 2;
   */
  locallyExecuted: bigint;

  /**
   * @generated from field: uint64 cluster_executed = 3;
   */
  clusterExecuted: bigint;
};

/**
 * Describes the message thru.services.v1.StreamHeightResponse.
 * Use `create(StreamHeightResponseSchema)` to create a new message.
 */
export const StreamHeightResponseSchema: GenMessage<StreamHeightResponse> = /*@__PURE__*/
  messageDesc(file_thru_services_v1_streaming_service, 15);

/**
 * StreamingService serves server-streaming gRPC APIs for real-time data.
 *
 * @generated from service thru.services.v1.StreamingService
 */
export const StreamingService: GenService<{
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamBlocks
   */
  streamBlocks: {
    methodKind: "server_streaming";
    input: typeof StreamBlocksRequestSchema;
    output: typeof StreamBlocksResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamAccountUpdates
   */
  streamAccountUpdates: {
    methodKind: "server_streaming";
    input: typeof StreamAccountUpdatesRequestSchema;
    output: typeof StreamAccountUpdatesResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamTransactions
   */
  streamTransactions: {
    methodKind: "server_streaming";
    input: typeof StreamTransactionsRequestSchema;
    output: typeof StreamTransactionsResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamEvents
   */
  streamEvents: {
    methodKind: "server_streaming";
    input: typeof StreamEventsRequestSchema;
    output: typeof StreamEventsResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.TrackTransaction
   */
  trackTransaction: {
    methodKind: "server_streaming";
    input: typeof TrackTransactionRequestSchema;
    output: typeof TrackTransactionResponseSchema;
  },
  /**
   * @generated from rpc thru.services.v1.StreamingService.StreamHeight
   */
  streamHeight: {
    methodKind: "server_streaming";
    input: typeof StreamHeightRequestSchema;
    output: typeof StreamHeightResponseSchema;
  },
  /**
   * Stream per-slot metrics including state counters and collected fees.
   * Metrics are emitted after each block's execution completes.
   *
   * @generated from rpc thru.services.v1.StreamingService.StreamSlotMetrics
   */
  streamSlotMetrics: {
    methodKind: "server_streaming";
    input: typeof StreamSlotMetricsRequestSchema;
    output: typeof StreamSlotMetricsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_thru_services_v1_streaming_service, 0);

