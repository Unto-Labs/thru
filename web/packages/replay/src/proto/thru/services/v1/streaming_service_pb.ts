// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file thru/services/v1/streaming_service.proto (package thru.services.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Filter } from "../../common/v1/filters_pb";
import { Block, BlockView } from "../../core/v1/block_pb";
import { ConsensusStatus } from "../../common/v1/consensus_pb";
import { Pubkey, Signature } from "../../common/v1/primitives_pb";
import { Account, AccountMeta, AccountPage, AccountView } from "../../core/v1/account_pb";
import { Transaction, TransactionExecutionResult } from "../../core/v1/transaction_pb";

/**
 * StreamBlocksRequest subscribes to real-time block updates.
 *
 * Filter expressions support the following params:
 *
 * - params.slot (int64): Slot number for comparison
 *   Example: block.block.header.slot == params.slot
 *
 * - params.min_slot (int64): Minimum slot for range filtering
 *   Example: block.block.header.slot >= params.min_slot
 *
 * - params.start_slot (int64): Starting slot for filtering
 *   Example: block.block.header.slot >= params.start_slot
 *
 * - params.u64 (int64): Generic 64-bit value for numeric comparisons
 *   Examples:
 *     block.block.header.max_compute_units > params.u64
 *     block.block.header.price >= params.u64
 *
 * - params.producer (bytes|Pubkey): Producer pubkey for filtering
 *   Examples:
 *     block.block.header.producer.value == params.producer
 *     has(block.block.header.producer) && block.block.header.producer.value == params.producer
 *
 * Available block header fields:
 *   block.block.header.slot, block.block.header.version,
 *   block.block.header.start_slot, block.block.header.expiry_after,
 *   block.block.header.max_block_size, block.block.header.max_compute_units,
 *   block.block.header.max_state_units, block.block.header.price,
 *   block.block.header.producer, block.block.header.producer.value
 *
 * Available block footer fields:
 *   block.block.footer.status, block.block.footer.consumed_compute_units,
 *   block.block.footer.consumed_state_units
 *
 * Available consensus status field:
 *   block.block.consensus_status
 *
 * Filter expression examples:
 *
 * 1. Filter by specific slot:
 *    Expression: "block.block.header.slot == params.slot"
 *    Params: {"slot": 12345}
 *
 * 2. Filter by slot range:
 *    Expression: "block.block.header.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 3. Filter by block version:
 *    Expression: "block.block.header.version >= uint(0)"
 *
 * 4. Filter by specific producer:
 *    Expression: "has(block.block.header.producer) && block.block.header.producer.value == params.producer"
 *    Params: {"producer": <32-byte pubkey>}
 *
 * 5. Filter by max compute units:
 *    Expression: "block.block.header.max_compute_units > uint(0)"
 *
 * 6. Filter by max state units:
 *    Expression: "block.block.header.max_state_units > uint(0)"
 *
 * 7. Filter by block price:
 *    Expression: "block.block.header.price >= uint(0)"
 *
 * 8. Filter by footer status:
 *    Expression: "has(block.block.footer) && block.block.footer.status == int(1)"
 *    Note: EXECUTION_STATUS_PENDING = 1, EXECUTION_STATUS_EXECUTED = 2
 *
 * 9. Filter by consumed compute units:
 *    Expression: "has(block.block.footer) && block.block.footer.consumed_compute_units > uint(0)"
 *
 * 10. Filter by consumed state units:
 *     Expression: "has(block.block.footer) && block.block.footer.consumed_state_units > uint(0)"
 *
 * 11. Filter by consensus status:
 *     Expression: "block.block.consensus_status == int(2)"
 *     Note: CONSENSUS_STATUS_UNSPECIFIED = 0, CONSENSUS_STATUS_OBSERVED = 1,
 *           CONSENSUS_STATUS_INCLUDED = 2
 *
 * 12. Check for optional fields presence:
 *     Expression: "has(block.block.header) && has(block.block.footer)"
 *
 * 13. Combined filters (multiple conditions):
 *     Expression: "block.block.header.slot >= params.min_slot && has(block.block.footer) && block.block.footer.consumed_compute_units > uint(0)"
 *     Params: {"min_slot": 1000}
 *
 * 14. Numeric comparison with params:
 *     Expression: "block.block.header.max_compute_units > params.u64"
 *     Params: {"u64": 1000000}
 *
 * @generated from message thru.services.v1.StreamBlocksRequest
 */
export class StreamBlocksRequest extends Message<StreamBlocksRequest> {
  /**
   * @generated from field: optional uint64 start_slot = 1;
   */
  startSlot?: bigint;

  /**
   * @generated from field: optional thru.common.v1.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.core.v1.BlockView view = 3;
   */
  view?: BlockView;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<StreamBlocksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamBlocksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 3, name: "view", kind: "enum", T: proto3.getEnumType(BlockView), opt: true },
    { no: 4, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBlocksRequest {
    return new StreamBlocksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBlocksRequest {
    return new StreamBlocksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBlocksRequest {
    return new StreamBlocksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamBlocksRequest | PlainMessage<StreamBlocksRequest> | undefined, b: StreamBlocksRequest | PlainMessage<StreamBlocksRequest> | undefined): boolean {
    return proto3.util.equals(StreamBlocksRequest, a, b);
  }
}

/**
 * StreamBlocksResponse delivers block updates.
 *
 * @generated from message thru.services.v1.StreamBlocksResponse
 */
export class StreamBlocksResponse extends Message<StreamBlocksResponse> {
  /**
   * @generated from field: thru.core.v1.Block block = 1;
   */
  block?: Block;

  constructor(data?: PartialMessage<StreamBlocksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamBlocksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block", kind: "message", T: Block },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBlocksResponse {
    return new StreamBlocksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBlocksResponse {
    return new StreamBlocksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBlocksResponse {
    return new StreamBlocksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamBlocksResponse | PlainMessage<StreamBlocksResponse> | undefined, b: StreamBlocksResponse | PlainMessage<StreamBlocksResponse> | undefined): boolean {
    return proto3.util.equals(StreamBlocksResponse, a, b);
  }
}

/**
 * StreamAccountUpdatesRequest subscribes to account delta events.
 *
 * Filter expressions support the following params:
 *
 * - params.min_slot (uint64): Minimum slot for filtering updates
 *   Example: account_update.slot >= params.min_slot
 *
 * - params.min_balance (uint64): Minimum balance for filtering
 *   Example: snapshot.meta.balance >= params.min_balance
 *
 * - params.owner (bytes|Pubkey): Owner pubkey for filtering
 *   Examples:
 *     snapshot.meta.owner.value == params.owner
 *     account_update.meta.owner.value == params.owner
 *
 * - params.address (bytes|Pubkey): Account address for filtering
 *   Example: snapshot.address.value == params.address
 *
 * Available snapshot fields (thru.core.v1.Account):
 *   snapshot.address, snapshot.address.value (bytes),
 *   snapshot.meta.balance (uint64), snapshot.meta.seq (uint64),
 *   snapshot.meta.nonce (uint64), snapshot.meta.data_size (uint32),
 *   snapshot.meta.version (uint32), snapshot.meta.flags (AccountFlags),
 *   snapshot.meta.flags.is_program (bool), snapshot.meta.flags.is_privileged (bool),
 *   snapshot.meta.flags.is_uncompressable (bool), snapshot.meta.flags.is_ephemeral (bool),
 *   snapshot.meta.flags.is_deleted (bool), snapshot.meta.flags.is_new (bool),
 *   snapshot.meta.flags.is_compressed (bool),
 *   snapshot.meta.owner, snapshot.meta.owner.value (bytes)
 *
 * Available account_update fields (AccountUpdate):
 *   account_update.slot (uint64), account_update.delete (bool),
 *   account_update.meta.balance (uint64), account_update.meta.seq (uint64),
 *   account_update.meta.nonce (uint64), account_update.meta.data_size (uint32),
 *   account_update.meta.version (uint32), account_update.meta.flags (AccountFlags),
 *   account_update.meta.flags.is_program (bool), account_update.meta.flags.is_privileged (bool),
 *   account_update.meta.flags.is_uncompressable (bool), account_update.meta.flags.is_ephemeral (bool),
 *   account_update.meta.flags.is_deleted (bool), account_update.meta.flags.is_new (bool),
 *   account_update.meta.flags.is_compressed (bool),
 *   account_update.meta.owner, account_update.meta.owner.value (bytes)
 *
 * Filter expression examples:
 *
 * 1. Filter by minimum balance (snapshot or update):
 *    Expression: "(has(snapshot.meta) && snapshot.meta.balance >= uint(1000000)) || (has(account_update.meta) && account_update.meta.balance >= uint(1000000))"
 *
 * 2. Filter by account owner using params:
 *    Expression: "(has(snapshot.meta) && has(snapshot.meta.owner) && snapshot.meta.owner.value == params.owner) || (has(account_update.meta) && has(account_update.meta.owner) && account_update.meta.owner.value == params.owner)"
 *    Params: {"owner": <32-byte pubkey>}
 *
 * 3. Filter by specific account address:
 *    Expression: "has(snapshot.address) && snapshot.address.value == params.address"
 *    Params: {"address": <32-byte pubkey>}
 *
 * 4. Filter by minimum slot for updates:
 *    Expression: "has(account_update.meta) && account_update.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 5. Filter by nonce greater than value:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.nonce >= uint(5)) || (has(account_update.meta) && account_update.meta.nonce >= uint(5))"
 *
 * 6. Filter by sequence number:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.seq >= uint(100)) || (has(account_update.meta) && account_update.meta.seq >= uint(100))"
 *
 * 7. Filter by data size:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.data_size >= uint(1024)) || (has(account_update.meta) && account_update.meta.data_size >= uint(1024))"
 *
 * 8. Filter by account version:
 *    Expression: "(has(snapshot.meta) && snapshot.meta.version >= uint(1)) || (has(account_update.meta) && account_update.meta.version >= uint(1))"
 *
 * 9. Filter by account flags (check if account is a program):
 *    Expression: "(has(snapshot.meta) && has(snapshot.meta.flags) && snapshot.meta.flags.is_program) || (has(account_update.meta) && has(account_update.meta.flags) && account_update.meta.flags.is_program)"
 *
 * 10. Filter by privileged flag:
 *     Expression: "(has(snapshot.meta) && has(snapshot.meta.flags) && snapshot.meta.flags.is_privileged) || (has(account_update.meta) && has(account_update.meta.flags) && account_update.meta.flags.is_privileged)"
 *
 * 11. Filter non-delete updates:
 *     Expression: "has(snapshot.meta) || (has(account_update.meta) && (!has(account_update.delete) || !account_update.delete))"
 *
 * 12. Check for snapshot or update presence:
 *     Expression: "has(snapshot.meta) || has(account_update.meta)"
 *
 * 13. Combined filters (multiple conditions):
 *     Expression: "has(snapshot.meta) || (has(account_update.meta) && account_update.slot >= params.min_slot && account_update.meta.balance >= params.min_balance)"
 *     Params: {"min_slot": 1000, "min_balance": 1000000}
 *
 * 14. Filter by minimum balance using params:
 *     Expression: "(has(snapshot.meta) && snapshot.meta.balance >= params.min_balance) || (has(account_update.meta) && account_update.meta.balance >= params.min_balance)"
 *     Params: {"min_balance": 5000000000}
 *
 * Note: The response contains either a snapshot (initial state), an update (delta),
 * or a BlockFinished message. Filters should handle both snapshot and update cases
 * using OR logic to match either message type.
 *
 * @generated from message thru.services.v1.StreamAccountUpdatesRequest
 */
export class StreamAccountUpdatesRequest extends Message<StreamAccountUpdatesRequest> {
  /**
   * @generated from field: thru.common.v1.Pubkey address = 1;
   */
  address?: Pubkey;

  /**
   * @generated from field: optional thru.core.v1.AccountView view = 2;
   */
  view?: AccountView;

  /**
   * @generated from field: optional thru.common.v1.Filter filter = 4;
   */
  filter?: Filter;

  constructor(data?: PartialMessage<StreamAccountUpdatesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamAccountUpdatesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "message", T: Pubkey },
    { no: 2, name: "view", kind: "enum", T: proto3.getEnumType(AccountView), opt: true },
    { no: 4, name: "filter", kind: "message", T: Filter, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAccountUpdatesRequest {
    return new StreamAccountUpdatesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAccountUpdatesRequest {
    return new StreamAccountUpdatesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAccountUpdatesRequest {
    return new StreamAccountUpdatesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamAccountUpdatesRequest | PlainMessage<StreamAccountUpdatesRequest> | undefined, b: StreamAccountUpdatesRequest | PlainMessage<StreamAccountUpdatesRequest> | undefined): boolean {
    return proto3.util.equals(StreamAccountUpdatesRequest, a, b);
  }
}

/**
 * AccountUpdate describes a delta for an account.
 *
 * @generated from message thru.services.v1.AccountUpdate
 */
export class AccountUpdate extends Message<AccountUpdate> {
  /**
   * @generated from field: uint64 slot = 1;
   */
  slot = protoInt64.zero;

  /**
   * @generated from field: optional thru.core.v1.AccountPage page = 2;
   */
  page?: AccountPage;

  /**
   * @generated from field: optional thru.core.v1.AccountMeta meta = 3;
   */
  meta?: AccountMeta;

  /**
   * @generated from field: optional bool delete = 4;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<AccountUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.AccountUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "page", kind: "message", T: AccountPage, opt: true },
    { no: 3, name: "meta", kind: "message", T: AccountMeta, opt: true },
    { no: 4, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountUpdate {
    return new AccountUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountUpdate {
    return new AccountUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountUpdate {
    return new AccountUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: AccountUpdate | PlainMessage<AccountUpdate> | undefined, b: AccountUpdate | PlainMessage<AccountUpdate> | undefined): boolean {
    return proto3.util.equals(AccountUpdate, a, b);
  }
}

/**
 * BlockFinished is sent when block's execution is complete.
 *
 * @generated from message thru.services.v1.BlockFinished
 */
export class BlockFinished extends Message<BlockFinished> {
  /**
   * @generated from field: uint64 slot = 1;
   */
  slot = protoInt64.zero;

  constructor(data?: PartialMessage<BlockFinished>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.BlockFinished";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockFinished {
    return new BlockFinished().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockFinished {
    return new BlockFinished().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockFinished {
    return new BlockFinished().fromJsonString(jsonString, options);
  }

  static equals(a: BlockFinished | PlainMessage<BlockFinished> | undefined, b: BlockFinished | PlainMessage<BlockFinished> | undefined): boolean {
    return proto3.util.equals(BlockFinished, a, b);
  }
}

/**
 * StreamAccountUpdatesResponse contains either an initial snapshot or a delta.
 *
 * @generated from message thru.services.v1.StreamAccountUpdatesResponse
 */
export class StreamAccountUpdatesResponse extends Message<StreamAccountUpdatesResponse> {
  /**
   * @generated from oneof thru.services.v1.StreamAccountUpdatesResponse.message
   */
  message: {
    /**
     * @generated from field: thru.core.v1.Account snapshot = 1;
     */
    value: Account;
    case: "snapshot";
  } | {
    /**
     * @generated from field: thru.services.v1.AccountUpdate update = 2;
     */
    value: AccountUpdate;
    case: "update";
  } | {
    /**
     * @generated from field: thru.services.v1.BlockFinished finished = 3;
     */
    value: BlockFinished;
    case: "finished";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamAccountUpdatesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamAccountUpdatesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "snapshot", kind: "message", T: Account, oneof: "message" },
    { no: 2, name: "update", kind: "message", T: AccountUpdate, oneof: "message" },
    { no: 3, name: "finished", kind: "message", T: BlockFinished, oneof: "message" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAccountUpdatesResponse {
    return new StreamAccountUpdatesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAccountUpdatesResponse {
    return new StreamAccountUpdatesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAccountUpdatesResponse {
    return new StreamAccountUpdatesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamAccountUpdatesResponse | PlainMessage<StreamAccountUpdatesResponse> | undefined, b: StreamAccountUpdatesResponse | PlainMessage<StreamAccountUpdatesResponse> | undefined): boolean {
    return proto3.util.equals(StreamAccountUpdatesResponse, a, b);
  }
}

/**
 * StreamTransactionsRequest subscribes to transaction confirmations.
 *
 * Filter expressions support the following params:
 *
 * - params.min_slot (uint64): Minimum slot for filtering transactions
 *   Example: transaction.slot >= params.min_slot
 *
 * - params.max_slot (uint64): Maximum slot for filtering transactions
 *   Example: transaction.slot <= params.max_slot
 *
 * - params.slot (uint64): Specific slot for exact match filtering
 *   Example: transaction.slot == params.slot
 *
 * - params.min_fee (uint64): Minimum fee for filtering transactions
 *   Example: transaction.header.fee >= params.min_fee
 *
 * - params.fee_payer (bytes|Pubkey): Fee payer pubkey for filtering
 *   Example: transaction.header.fee_payer_pubkey.value == params.fee_payer
 *
 * - params.signature (bytes|Signature): Transaction signature for filtering
 *   Example: transaction.signature.value == params.signature
 *
 * Available transaction fields (thru.core.v1.Transaction):
 *   transaction.signature, transaction.signature.value (bytes),
 *   transaction.slot (uint64), transaction.block_offset (uint32),
 *   transaction.header, transaction.header.version (uint32),
 *   transaction.header.fee (uint64),
 *   transaction.header.fee_payer_pubkey, transaction.header.fee_payer_pubkey.value (bytes),
 *   transaction.execution_result, transaction.execution_result.user_error_code (uint32),
 *   transaction.execution_result.vm_error (int32)
 *
 * Available consensus_status field:
 *   consensus_status (int32) - Current consensus status of the transaction
 *   Values: CONSENSUS_STATUS_UNSPECIFIED = 0, CONSENSUS_STATUS_OBSERVED = 1,
 *           CONSENSUS_STATUS_INCLUDED = 2
 *
 * Filter expression examples:
 *
 * 1. Filter by minimum slot:
 *    Expression: "has(transaction.slot) && transaction.slot >= params.min_slot"
 *    Params: {"min_slot": 1000}
 *
 * 2. Filter by slot range:
 *    Expression: "has(transaction.slot) && transaction.slot >= params.min_slot && transaction.slot <= params.max_slot"
 *    Params: {"min_slot": 1000, "max_slot": 2000}
 *
 * 3. Filter by specific slot:
 *    Expression: "has(transaction.slot) && transaction.slot == params.slot"
 *    Params: {"slot": 12345}
 *
 * 4. Filter by minimum fee:
 *    Expression: "has(transaction.header) && transaction.header.fee >= params.min_fee"
 *    Params: {"min_fee": 5000}
 *
 * 5. Filter by fee payer:
 *    Expression: "has(transaction.header.fee_payer_pubkey) && transaction.header.fee_payer_pubkey.value == params.fee_payer"
 *    Params: {"fee_payer": <32-byte pubkey>}
 *
 * 6. Filter by transaction signature:
 *    Expression: "has(transaction.signature) && transaction.signature.value == params.signature"
 *    Params: {"signature": <64-byte signature>}
 *
 * 7. Filter by header version:
 *    Expression: "has(transaction.header) && transaction.header.version >= uint(0)"
 *
 * 8. Filter by successful execution:
 *    Expression: "has(transaction.execution_result) && transaction.execution_result.vm_error == int(0)"
 *
 * 9. Filter by user error code:
 *    Expression: "has(transaction.execution_result) && transaction.execution_result.user_error_code == uint(0)"
 *
 * 10. Filter by consensus status:
 *     Expression: "consensus_status >= int(2)"
 *     Note: Use >= int(2) for CONSENSUS_STATUS_INCLUDED and above
 *
 * 11. Check for execution result presence:
 *     Expression: "has(transaction.execution_result)"
 *
 * 12. Filter by transaction with header and slot:
 *     Expression: "has(transaction.slot) && transaction.slot >= uint(0) && has(transaction.header)"
 *
 * 13. Combined filters (slot, fee, and status):
 *     Expression: "has(transaction.slot) && transaction.slot >= params.min_slot && has(transaction.header) && transaction.header.fee >= params.min_fee && consensus_status >= int(2)"
 *     Params: {"min_slot": 1000, "min_fee": 5000}
 *
 * 14. Filter successful transactions with minimum fee:
 *     Expression: "has(transaction.execution_result) && transaction.execution_result.vm_error == int(0) && has(transaction.header) && transaction.header.fee >= params.min_fee"
 *     Params: {"min_fee": 10000}
 *
 * Note: The min_consensus field in the request provides built-in consensus filtering
 * without requiring a CEL expression. Use it in combination with filter expressions
 * for more complex filtering logic.
 *
 * @generated from message thru.services.v1.StreamTransactionsRequest
 */
export class StreamTransactionsRequest extends Message<StreamTransactionsRequest> {
  /**
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 2;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<StreamTransactionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamTransactionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 2, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamTransactionsRequest {
    return new StreamTransactionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamTransactionsRequest {
    return new StreamTransactionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamTransactionsRequest {
    return new StreamTransactionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamTransactionsRequest | PlainMessage<StreamTransactionsRequest> | undefined, b: StreamTransactionsRequest | PlainMessage<StreamTransactionsRequest> | undefined): boolean {
    return proto3.util.equals(StreamTransactionsRequest, a, b);
  }
}

/**
 * StreamTransactionsResponse delivers transaction events.
 *
 * @generated from message thru.services.v1.StreamTransactionsResponse
 */
export class StreamTransactionsResponse extends Message<StreamTransactionsResponse> {
  /**
   * @generated from field: thru.core.v1.Transaction transaction = 1;
   */
  transaction?: Transaction;

  constructor(data?: PartialMessage<StreamTransactionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamTransactionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction", kind: "message", T: Transaction },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamTransactionsResponse {
    return new StreamTransactionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamTransactionsResponse {
    return new StreamTransactionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamTransactionsResponse {
    return new StreamTransactionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamTransactionsResponse | PlainMessage<StreamTransactionsResponse> | undefined, b: StreamTransactionsResponse | PlainMessage<StreamTransactionsResponse> | undefined): boolean {
    return proto3.util.equals(StreamTransactionsResponse, a, b);
  }
}

/**
 * StreamEventsRequest subscribes to chain events.
 *
 * Filter expressions support the following params:
 *
 * - params.prefix (bytes): Byte prefix for payload filtering
 *   Example: bytesPrefix(event.payload, params.prefix)
 *
 * - params.slot (uint64): Slot number for comparison
 *   Example: event.slot >= params.slot
 *
 * - params.u64 (uint64): Generic 64-bit value for payload extraction
 *   Examples:
 *     first8Bytes(event.payload) == params.u64
 *     first4Bytes(event.payload) == params.u64
 *     first1Byte(event.payload) == params.u64
 *
 * - params.signature (bytes|Signature|TsSignature): Signature for comparison
 *   Examples:
 *     event.signature == params.signature              // TsSignature type
 *     event.signature.value == params.signature        // bytes type
 *     bytesPrefix(event.signature.value, params.signature)
 *
 * - params.address (bytes|Pubkey|TaPubkey): Address/pubkey for comparison
 *   Examples:
 *     event.program == params.address                  // TaPubkey type
 *     event.program.value == params.address            // bytes type
 *     bytesPrefix(event.program.value, params.address)
 *
 * Available event fields:
 *   event.event_id, event.slot, event.payload, event.call_idx,
 *   event.signature (Signature), event.signature.value (bytes),
 *   event.program (Pubkey), event.program.value (bytes)
 *
 * @generated from message thru.services.v1.StreamEventsRequest
 */
export class StreamEventsRequest extends Message<StreamEventsRequest> {
  /**
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;

  constructor(data?: PartialMessage<StreamEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: Filter, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamEventsRequest {
    return new StreamEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamEventsRequest {
    return new StreamEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamEventsRequest {
    return new StreamEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamEventsRequest | PlainMessage<StreamEventsRequest> | undefined, b: StreamEventsRequest | PlainMessage<StreamEventsRequest> | undefined): boolean {
    return proto3.util.equals(StreamEventsRequest, a, b);
  }
}

/**
 * StreamEventsResponse delivers event payloads.
 *
 * @generated from message thru.services.v1.StreamEventsResponse
 */
export class StreamEventsResponse extends Message<StreamEventsResponse> {
  /**
   * @generated from field: string event_id = 1;
   */
  eventId = "";

  /**
   * @generated from field: optional bytes payload = 2;
   */
  payload?: Uint8Array;

  /**
   * @generated from field: optional google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: thru.common.v1.Pubkey program = 4;
   */
  program?: Pubkey;

  /**
   * @generated from field: uint32 call_idx = 5;
   */
  callIdx = 0;

  /**
   * @generated from field: thru.common.v1.Signature signature = 6;
   */
  signature?: Signature;

  /**
   * @generated from field: uint64 slot = 7;
   */
  slot = protoInt64.zero;

  constructor(data?: PartialMessage<StreamEventsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamEventsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payload", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp, opt: true },
    { no: 4, name: "program", kind: "message", T: Pubkey },
    { no: 5, name: "call_idx", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "signature", kind: "message", T: Signature },
    { no: 7, name: "slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamEventsResponse {
    return new StreamEventsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamEventsResponse {
    return new StreamEventsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamEventsResponse {
    return new StreamEventsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamEventsResponse | PlainMessage<StreamEventsResponse> | undefined, b: StreamEventsResponse | PlainMessage<StreamEventsResponse> | undefined): boolean {
    return proto3.util.equals(StreamEventsResponse, a, b);
  }
}

/**
 * TrackTransactionRequest subscribes to status updates for a transaction.
 *
 * @generated from message thru.services.v1.TrackTransactionRequest
 */
export class TrackTransactionRequest extends Message<TrackTransactionRequest> {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: optional google.protobuf.Duration timeout = 2;
   */
  timeout?: Duration;

  constructor(data?: PartialMessage<TrackTransactionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.TrackTransactionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "message", T: Signature },
    { no: 2, name: "timeout", kind: "message", T: Duration, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrackTransactionRequest {
    return new TrackTransactionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrackTransactionRequest {
    return new TrackTransactionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrackTransactionRequest {
    return new TrackTransactionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TrackTransactionRequest | PlainMessage<TrackTransactionRequest> | undefined, b: TrackTransactionRequest | PlainMessage<TrackTransactionRequest> | undefined): boolean {
    return proto3.util.equals(TrackTransactionRequest, a, b);
  }
}

/**
 * TrackTransactionResponse reports status transitions for a transaction.
 *
 * @generated from message thru.services.v1.TrackTransactionResponse
 */
export class TrackTransactionResponse extends Message<TrackTransactionResponse> {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: thru.common.v1.ConsensusStatus consensus_status = 2;
   */
  consensusStatus = ConsensusStatus.UNSPECIFIED;

  /**
   * @generated from field: thru.core.v1.TransactionExecutionResult execution_result = 3;
   */
  executionResult?: TransactionExecutionResult;

  constructor(data?: PartialMessage<TrackTransactionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.TrackTransactionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "message", T: Signature },
    { no: 2, name: "consensus_status", kind: "enum", T: proto3.getEnumType(ConsensusStatus) },
    { no: 3, name: "execution_result", kind: "message", T: TransactionExecutionResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrackTransactionResponse {
    return new TrackTransactionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrackTransactionResponse {
    return new TrackTransactionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrackTransactionResponse {
    return new TrackTransactionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TrackTransactionResponse | PlainMessage<TrackTransactionResponse> | undefined, b: TrackTransactionResponse | PlainMessage<TrackTransactionResponse> | undefined): boolean {
    return proto3.util.equals(TrackTransactionResponse, a, b);
  }
}

/**
 * StreamHeightRequest subscribes to real-time height updates.
 *
 * @generated from message thru.services.v1.StreamHeightRequest
 */
export class StreamHeightRequest extends Message<StreamHeightRequest> {
  constructor(data?: PartialMessage<StreamHeightRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamHeightRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamHeightRequest {
    return new StreamHeightRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamHeightRequest {
    return new StreamHeightRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamHeightRequest {
    return new StreamHeightRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamHeightRequest | PlainMessage<StreamHeightRequest> | undefined, b: StreamHeightRequest | PlainMessage<StreamHeightRequest> | undefined): boolean {
    return proto3.util.equals(StreamHeightRequest, a, b);
  }
}

/**
 * StreamHeightResponse delivers height update events.
 *
 * @generated from message thru.services.v1.StreamHeightResponse
 */
export class StreamHeightResponse extends Message<StreamHeightResponse> {
  /**
   * @generated from field: uint64 finalized = 1;
   */
  finalized = protoInt64.zero;

  /**
   * @generated from field: uint64 locally_executed = 2;
   */
  locallyExecuted = protoInt64.zero;

  /**
   * @generated from field: uint64 cluster_executed = 3;
   */
  clusterExecuted = protoInt64.zero;

  constructor(data?: PartialMessage<StreamHeightResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.StreamHeightResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "finalized", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "locally_executed", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "cluster_executed", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamHeightResponse {
    return new StreamHeightResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamHeightResponse {
    return new StreamHeightResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamHeightResponse {
    return new StreamHeightResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamHeightResponse | PlainMessage<StreamHeightResponse> | undefined, b: StreamHeightResponse | PlainMessage<StreamHeightResponse> | undefined): boolean {
    return proto3.util.equals(StreamHeightResponse, a, b);
  }
}

