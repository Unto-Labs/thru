// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file thru/services/v1/query_service.proto (package thru.services.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Pubkey, Signature } from "../../common/v1/primitives_pb";
import { Account, AccountView, DataSlice } from "../../core/v1/account_pb";
import { ConsensusStatus, VersionContext } from "../../common/v1/consensus_pb";
import { Transaction, TransactionExecutionResult, TransactionView } from "../../core/v1/transaction_pb";
import { StateProof, StateProofRequest } from "../../core/v1/state_pb";
import { BlockHash } from "../../core/v1/types_pb";
import { Block, BlockView } from "../../core/v1/block_pb";
import { Filter } from "../../common/v1/filters_pb";
import { PageRequest, PageResponse } from "../../common/v1/pagination_pb";

/**
 * GetAccountRequest retrieves a decoded account by public key.
 *
 * @generated from message thru.services.v1.GetAccountRequest
 */
export class GetAccountRequest extends Message<GetAccountRequest> {
  /**
   * @generated from field: thru.common.v1.Pubkey address = 1;
   */
  address?: Pubkey;

  /**
   * @generated from field: optional thru.core.v1.AccountView view = 2;
   */
  view?: AccountView;

  /**
   * @generated from field: thru.common.v1.VersionContext version_context = 3;
   */
  versionContext?: VersionContext;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;

  /**
   * @generated from field: optional thru.core.v1.DataSlice data_slice = 5;
   */
  dataSlice?: DataSlice;

  constructor(data?: PartialMessage<GetAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "message", T: Pubkey },
    { no: 2, name: "view", kind: "enum", T: proto3.getEnumType(AccountView), opt: true },
    { no: 3, name: "version_context", kind: "message", T: VersionContext },
    { no: 4, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
    { no: 5, name: "data_slice", kind: "message", T: DataSlice, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountRequest {
    return new GetAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountRequest {
    return new GetAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountRequest {
    return new GetAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountRequest | PlainMessage<GetAccountRequest> | undefined, b: GetAccountRequest | PlainMessage<GetAccountRequest> | undefined): boolean {
    return proto3.util.equals(GetAccountRequest, a, b);
  }
}

/**
 * GetRawAccountRequest retrieves raw account bytes by public key.
 *
 * @generated from message thru.services.v1.GetRawAccountRequest
 */
export class GetRawAccountRequest extends Message<GetRawAccountRequest> {
  /**
   * @generated from field: thru.common.v1.Pubkey address = 1;
   */
  address?: Pubkey;

  /**
   * @generated from field: optional thru.core.v1.AccountView view = 2;
   */
  view?: AccountView;

  /**
   * @generated from field: thru.common.v1.VersionContext version_context = 3;
   */
  versionContext?: VersionContext;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<GetRawAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetRawAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "message", T: Pubkey },
    { no: 2, name: "view", kind: "enum", T: proto3.getEnumType(AccountView), opt: true },
    { no: 3, name: "version_context", kind: "message", T: VersionContext },
    { no: 4, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRawAccountRequest {
    return new GetRawAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRawAccountRequest {
    return new GetRawAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRawAccountRequest {
    return new GetRawAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRawAccountRequest | PlainMessage<GetRawAccountRequest> | undefined, b: GetRawAccountRequest | PlainMessage<GetRawAccountRequest> | undefined): boolean {
    return proto3.util.equals(GetRawAccountRequest, a, b);
  }
}

/**
 * GetTransactionRequest retrieves a decoded transaction by signature.
 *
 * @generated from message thru.services.v1.GetTransactionRequest
 */
export class GetTransactionRequest extends Message<GetTransactionRequest> {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: optional thru.core.v1.TransactionView view = 2;
   */
  view?: TransactionView;

  /**
   * @generated from field: thru.common.v1.VersionContext version_context = 3;
   */
  versionContext?: VersionContext;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<GetTransactionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetTransactionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "message", T: Signature },
    { no: 2, name: "view", kind: "enum", T: proto3.getEnumType(TransactionView), opt: true },
    { no: 3, name: "version_context", kind: "message", T: VersionContext },
    { no: 4, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTransactionRequest {
    return new GetTransactionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTransactionRequest {
    return new GetTransactionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTransactionRequest {
    return new GetTransactionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTransactionRequest | PlainMessage<GetTransactionRequest> | undefined, b: GetTransactionRequest | PlainMessage<GetTransactionRequest> | undefined): boolean {
    return proto3.util.equals(GetTransactionRequest, a, b);
  }
}

/**
 * GetRawTransactionRequest retrieves raw transaction bytes by signature.
 *
 * @generated from message thru.services.v1.GetRawTransactionRequest
 */
export class GetRawTransactionRequest extends Message<GetRawTransactionRequest> {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: thru.common.v1.VersionContext version_context = 2;
   */
  versionContext?: VersionContext;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 3;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<GetRawTransactionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetRawTransactionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "message", T: Signature },
    { no: 2, name: "version_context", kind: "message", T: VersionContext },
    { no: 3, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRawTransactionRequest {
    return new GetRawTransactionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRawTransactionRequest {
    return new GetRawTransactionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRawTransactionRequest {
    return new GetRawTransactionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRawTransactionRequest | PlainMessage<GetRawTransactionRequest> | undefined, b: GetRawTransactionRequest | PlainMessage<GetRawTransactionRequest> | undefined): boolean {
    return proto3.util.equals(GetRawTransactionRequest, a, b);
  }
}

/**
 * GenerateStateProofRequest requests an account state proof.
 *
 * @generated from message thru.services.v1.GenerateStateProofRequest
 */
export class GenerateStateProofRequest extends Message<GenerateStateProofRequest> {
  /**
   * @generated from field: thru.core.v1.StateProofRequest request = 1;
   */
  request?: StateProofRequest;

  constructor(data?: PartialMessage<GenerateStateProofRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GenerateStateProofRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: StateProofRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateStateProofRequest {
    return new GenerateStateProofRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateStateProofRequest {
    return new GenerateStateProofRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateStateProofRequest {
    return new GenerateStateProofRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateStateProofRequest | PlainMessage<GenerateStateProofRequest> | undefined, b: GenerateStateProofRequest | PlainMessage<GenerateStateProofRequest> | undefined): boolean {
    return proto3.util.equals(GenerateStateProofRequest, a, b);
  }
}

/**
 * GenerateStateProofResponse contains the generated proof.
 *
 * @generated from message thru.services.v1.GenerateStateProofResponse
 */
export class GenerateStateProofResponse extends Message<GenerateStateProofResponse> {
  /**
   * @generated from field: thru.core.v1.StateProof proof = 1;
   */
  proof?: StateProof;

  constructor(data?: PartialMessage<GenerateStateProofResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GenerateStateProofResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proof", kind: "message", T: StateProof },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateStateProofResponse {
    return new GenerateStateProofResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateStateProofResponse {
    return new GenerateStateProofResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateStateProofResponse {
    return new GenerateStateProofResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateStateProofResponse | PlainMessage<GenerateStateProofResponse> | undefined, b: GenerateStateProofResponse | PlainMessage<GenerateStateProofResponse> | undefined): boolean {
    return proto3.util.equals(GenerateStateProofResponse, a, b);
  }
}

/**
 * GetBlockRequest retrieves decoded block information by slot or hash.
 *
 * @generated from message thru.services.v1.GetBlockRequest
 */
export class GetBlockRequest extends Message<GetBlockRequest> {
  /**
   * @generated from oneof thru.services.v1.GetBlockRequest.selector
   */
  selector: {
    /**
     * @generated from field: uint64 slot = 1;
     */
    value: bigint;
    case: "slot";
  } | {
    /**
     * @generated from field: thru.core.v1.BlockHash block_hash = 2;
     */
    value: BlockHash;
    case: "blockHash";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional thru.core.v1.BlockView view = 3;
   */
  view?: BlockView;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<GetBlockRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetBlockRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "selector" },
    { no: 2, name: "block_hash", kind: "message", T: BlockHash, oneof: "selector" },
    { no: 3, name: "view", kind: "enum", T: proto3.getEnumType(BlockView), opt: true },
    { no: 4, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetBlockRequest {
    return new GetBlockRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetBlockRequest {
    return new GetBlockRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetBlockRequest {
    return new GetBlockRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetBlockRequest | PlainMessage<GetBlockRequest> | undefined, b: GetBlockRequest | PlainMessage<GetBlockRequest> | undefined): boolean {
    return proto3.util.equals(GetBlockRequest, a, b);
  }
}

/**
 * GetRawBlockRequest retrieves raw block bytes by slot or hash.
 *
 * @generated from message thru.services.v1.GetRawBlockRequest
 */
export class GetRawBlockRequest extends Message<GetRawBlockRequest> {
  /**
   * @generated from oneof thru.services.v1.GetRawBlockRequest.selector
   */
  selector: {
    /**
     * @generated from field: uint64 slot = 1;
     */
    value: bigint;
    case: "slot";
  } | {
    /**
     * @generated from field: thru.core.v1.BlockHash block_hash = 2;
     */
    value: BlockHash;
    case: "blockHash";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 3;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<GetRawBlockRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetRawBlockRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "selector" },
    { no: 2, name: "block_hash", kind: "message", T: BlockHash, oneof: "selector" },
    { no: 3, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRawBlockRequest {
    return new GetRawBlockRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRawBlockRequest {
    return new GetRawBlockRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRawBlockRequest {
    return new GetRawBlockRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRawBlockRequest | PlainMessage<GetRawBlockRequest> | undefined, b: GetRawBlockRequest | PlainMessage<GetRawBlockRequest> | undefined): boolean {
    return proto3.util.equals(GetRawBlockRequest, a, b);
  }
}

/**
 * ListAccountsRequest lists accounts using CEL filters.
 *
 * The filter expression supports filtering on account metadata fields using CEL (Common Expression Language).
 * A filter expression is REQUIRED for all ListAccounts requests.
 *
 * Available fields for filtering:
 *   - account.address.value (bytes): The account's public key address
 *   - account.meta.owner.value (bytes): The account owner's public key
 *   - account.meta.balance (uint64): Account balance in native units
 *   - account.meta.seq (uint64): Account sequence number / state counter
 *   - account.meta.nonce (uint64): Account transaction nonce
 *   - account.meta.data_size (uint32): Size of account data in bytes
 *   - account.meta.version (uint32): Account version number
 *   - account.meta.flags (AccountFlags): Account capability flags (message type)
 *
 * Available CEL functions:
 *   - has(field): Check if optional field exists
 *   - uint(value): Convert to uint type
 *   - int(value): Convert to int type
 *   - string(value): Convert to string type
 *   - bytes(value): Convert to bytes type
 *
 * Available filter parameters (accessible via params.* in expressions):
 *   - params.owner_bytes (bytes): Owner public key for owner filtering (REQUIRED when filtering by owner)
 *   - params.prefix (bytes): Byte prefix for range-based filtering
 *   - params.tag (any): Custom tag parameter
 *   - params.min_slot (uint64): Minimum slot parameter
 *
 * Filter examples:
 *
 * 1. Filter by balance:
 *      filter.expression = "account.meta.balance > uint(1000000)"
 *
 * 2. Filter by balance range:
 *      filter.expression = "account.meta.balance >= uint(100) && account.meta.balance <= uint(10000)"
 *
 * 3. Filter by owner (requires params.owner_bytes):
 *      filter.expression = "account.meta.owner.value == params.owner_bytes"
 *      filter.params["owner_bytes"].bytes_value = <32-byte owner pubkey>
 *
 * 4. Filter by data size:
 *      filter.expression = "account.meta.data_size > uint(0)"
 *      filter.expression = "account.meta.data_size >= uint(100) && account.meta.data_size <= uint(1000)"
 *
 * 5. Filter by nonce:
 *      filter.expression = "account.meta.nonce == uint(0)"
 *
 * 6. Filter by sequence number:
 *      filter.expression = "account.meta.seq >= uint(100)"
 *
 * 7. Filter by version:
 *      filter.expression = "account.meta.version == uint(1)"
 *
 * 8. Filter by specific address (using inline bytes literal with octal escaping):
 *      filter.expression = "account.address.value == b'\001\002\003...'"
 *      Note: Binary bytes must be properly escaped using octal notation (\NNN) for non-printable bytes
 *
 * 9. Filter by address prefix (using range comparison):
 *      filter.expression = "account.address.value >= b'\001\002\003\004' && account.address.value <= b'\001\002\003\004\377\377...'"
 *      Note: Create upper bound by appending 0xff bytes after prefix
 *
 * 10. Combine multiple conditions with AND:
 *      filter.expression = "account.meta.balance > uint(0) && account.meta.data_size == uint(0)"
 *
 * 11. Combine multiple conditions with OR:
 *      filter.expression = "account.meta.balance == uint(0) || account.meta.balance > uint(50000)"
 *
 * 12. Complex combined filters:
 *      filter.expression = "(account.meta.balance > uint(100) && account.meta.balance < uint(10000)) || account.meta.data_size > uint(1000)"
 *
 * 13. Check for optional field existence:
 *      filter.expression = "has(account.address.value)"
 *      filter.expression = "has(account.meta.owner.value)"  // Requires params.owner_bytes
 *
 * 14. Use inequality operators:
 *      filter.expression = "account.meta.balance < uint(5000)"
 *      filter.expression = "account.meta.balance <= uint(5000)"
 *      filter.expression = "account.meta.balance >= uint(100)"
 *      filter.expression = "account.meta.balance != uint(999)"
 *
 * 15. Type conversions:
 *      filter.expression = "account.meta.balance == uint(100)"
 *      filter.expression = "uint(account.meta.data_size) > uint(0)"
 *
 * Limitations:
 *   - The startsWith() function only works with strings, not bytes
 *   - The bytesPrefix() function is NOT available for ListAccounts (use range comparison instead)
 *   - Individual flag fields (e.g., account.meta.flags.is_program) are NOT exposed
 *   - Parameter names other than owner_bytes, prefix, tag, min_slot are NOT permitted
 *   - All filters are pushed down to SQL for optimal performance where possible
 *
 * @generated from message thru.services.v1.ListAccountsRequest
 */
export class ListAccountsRequest extends Message<ListAccountsRequest> {
  /**
   * @generated from field: optional thru.core.v1.AccountView view = 1;
   */
  view?: AccountView;

  /**
   * @generated from field: optional thru.common.v1.VersionContext version_context = 2;
   */
  versionContext?: VersionContext;

  /**
   * CEL filter expression (REQUIRED). See message documentation for examples.
   *
   * @generated from field: optional thru.common.v1.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.common.v1.PageRequest page = 4;
   */
  page?: PageRequest;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 5;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<ListAccountsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListAccountsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "view", kind: "enum", T: proto3.getEnumType(AccountView), opt: true },
    { no: 2, name: "version_context", kind: "message", T: VersionContext, opt: true },
    { no: 3, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 4, name: "page", kind: "message", T: PageRequest, opt: true },
    { no: 5, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccountsRequest {
    return new ListAccountsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccountsRequest {
    return new ListAccountsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccountsRequest {
    return new ListAccountsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccountsRequest | PlainMessage<ListAccountsRequest> | undefined, b: ListAccountsRequest | PlainMessage<ListAccountsRequest> | undefined): boolean {
    return proto3.util.equals(ListAccountsRequest, a, b);
  }
}

/**
 * ListAccountsResponse contains paginated accounts.
 *
 * @generated from message thru.services.v1.ListAccountsResponse
 */
export class ListAccountsResponse extends Message<ListAccountsResponse> {
  /**
   * @generated from field: repeated thru.core.v1.Account accounts = 1;
   */
  accounts: Account[] = [];

  /**
   * @generated from field: optional thru.common.v1.PageResponse page = 2;
   */
  page?: PageResponse;

  constructor(data?: PartialMessage<ListAccountsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListAccountsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "message", T: Account, repeated: true },
    { no: 2, name: "page", kind: "message", T: PageResponse, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccountsResponse {
    return new ListAccountsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccountsResponse {
    return new ListAccountsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccountsResponse {
    return new ListAccountsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccountsResponse | PlainMessage<ListAccountsResponse> | undefined, b: ListAccountsResponse | PlainMessage<ListAccountsResponse> | undefined): boolean {
    return proto3.util.equals(ListAccountsResponse, a, b);
  }
}

/**
 * ListBlocksRequest lists blocks with pagination and filtering.
 *
 * Returns blocks ordered from latest slot to earliest (slot DESC) by default.
 * Supports filtering on block header and footer fields using CEL expressions.
 *
 * Available fields for filtering:
 *
 * Header fields:
 *   - block.header.slot (uint64): Block slot number
 *   - block.header.version (uint32): Block version number
 *   - block.header.start_slot (uint64): Start slot for block production
 *   - block.header.producer.value (bytes): Block producer's public key
 *   - block.header.expiry_after (uint32): Expiry duration in slots
 *   - block.header.expiry_timestamp (google.protobuf.Timestamp): Expiry timestamp
 *   - block.header.max_block_size (uint32): Maximum block size in bytes
 *   - block.header.max_compute_units (uint64): Maximum compute units allowed
 *   - block.header.max_state_units (uint32): Maximum state units allowed
 *   - block.header.price (uint64): Block production price
 *   - block.header.block_hash.value (bytes): Block hash
 *   - block.header.header_signature.value (bytes): Header signature
 *   - block.header.block_time (google.protobuf.Timestamp): Block timestamp
 *
 * Footer fields:
 *   - block.footer.signature.value (bytes): Block signature
 *   - block.footer.status (int32): Block execution status (2 = EXECUTION_STATUS_EXECUTED)
 *   - block.footer.consumed_compute_units (uint64): Total compute units consumed by all transactions
 *   - block.footer.consumed_state_units (uint32): Total state units consumed by all transactions
 *
 * Consensus status:
 *   - block.consensus_status (int32): Consensus status (always CONSENSUS_STATUS_INCLUDED for persisted blocks)
 *
 * Available CEL functions:
 *   - has(field): Check if optional field exists
 *   - uint(value): Convert to uint type
 *   - int(value): Convert to int type
 *   - bytes(value): Convert to bytes type
 *   - timestamp(value): Convert to timestamp type
 *   - duration(value): Convert to duration type
 *
 * Available filter parameters (accessible via params.* in expressions):
 *   - params.slot (uint64): Slot number for filtering
 *   - params.u64 (uint64): Generic uint64 parameter
 *   - params.producer (bytes): Producer public key for filtering
 *
 * Filter examples:
 *
 * 1. Filter by specific slot:
 *      filter.expression = "block.header.slot == uint(1234)"
 *
 * 2. Filter by slot range:
 *      filter.expression = "block.header.slot >= uint(1000) && block.header.slot <= uint(2000)"
 *
 * 3. Filter by slot using parameter:
 *      filter.expression = "block.header.slot == params.slot"
 *      filter.params["slot"].uint_value = 1234
 *
 * 4. Filter by block version:
 *      filter.expression = "block.header.version == uint(1)"
 *
 * 5. Filter by producer (using parameter):
 *      filter.expression = "block.header.producer.value == params.producer"
 *      filter.params["producer"].bytes_value = <32-byte producer pubkey>
 *
 * 6. Filter by max compute units:
 *      filter.expression = "block.header.max_compute_units > uint(1000000)"
 *      filter.expression = "block.header.max_compute_units >= uint(0) && block.header.max_compute_units <= uint(10000000)"
 *
 * 7. Filter by max state units:
 *      filter.expression = "block.header.max_state_units > uint(0)"
 *
 * 8. Filter by price:
 *      filter.expression = "block.header.price >= uint(0)"
 *      filter.expression = "block.header.price > uint(1000)"
 *
 * 9. Filter by start_slot:
 *      filter.expression = "block.header.start_slot <= uint(5000)"
 *
 * 10. Filter by expiry_after:
 *      filter.expression = "block.header.expiry_after > uint(0)"
 *
 * 11. Filter by max_block_size:
 *      filter.expression = "block.header.max_block_size >= uint(1000000)"
 *
 * 12. Filter by execution status:
 *      filter.expression = "block.footer.status == int(2)"  // EXECUTION_STATUS_EXECUTED
 *
 * 13. Filter by consumed compute units:
 *      filter.expression = "block.footer.consumed_compute_units > uint(0)"
 *      filter.expression = "block.footer.consumed_compute_units >= uint(100) && block.footer.consumed_compute_units <= uint(1000000)"
 *
 * 14. Filter by consumed state units:
 *      filter.expression = "block.footer.consumed_state_units >= uint(0)"
 *      filter.expression = "block.footer.consumed_state_units > uint(10)"
 *
 * 15. Check for footer signature existence:
 *      filter.expression = "has(block.footer.signature)"
 *
 * 16. Check for footer existence:
 *      filter.expression = "has(block.footer)"
 *
 * 17. Check for producer existence:
 *      filter.expression = "has(block.header.producer)"
 *
 * 18. Check for block hash existence:
 *      filter.expression = "has(block.header.block_hash)"
 *
 * 19. Check for header signature existence:
 *      filter.expression = "has(block.header.header_signature)"
 *
 * 20. Check for expiry timestamp existence:
 *      filter.expression = "has(block.header.expiry_timestamp)"
 *
 * 21. Check for block time existence:
 *      filter.expression = "has(block.header.block_time)"
 *
 * 22. Combine multiple header conditions with AND:
 *      filter.expression = "block.header.slot >= uint(1000) && block.header.max_compute_units > uint(1000000)"
 *
 * 23. Combine multiple footer conditions with AND:
 *      filter.expression = "block.footer.consumed_compute_units > uint(0) && block.footer.consumed_state_units > uint(0)"
 *
 * 24. Combine header and footer conditions:
 *      filter.expression = "block.header.slot >= uint(1000) && block.footer.consumed_compute_units > uint(100000)"
 *
 * 25. Combine multiple conditions with OR:
 *      filter.expression = "block.header.slot == uint(100) || block.header.slot == uint(200)"
 *      filter.expression = "block.footer.consumed_compute_units > uint(1000000) || block.footer.consumed_state_units > uint(10000)"
 *
 * 26. Complex combined filters:
 *      filter.expression = "(block.header.slot >= uint(1000) && block.header.slot <= uint(2000)) || block.footer.consumed_compute_units > uint(5000000)"
 *
 * 27. Use inequality operators:
 *      filter.expression = "block.header.max_compute_units < uint(10000000)"
 *      filter.expression = "block.header.max_compute_units <= uint(10000000)"
 *      filter.expression = "block.header.price >= uint(100)"
 *      filter.expression = "block.footer.consumed_compute_units != uint(0)"
 *
 * 28. Combine has() with value checks:
 *      filter.expression = "has(block.header.producer) && block.header.producer.value == params.producer"
 *      filter.params["producer"].bytes_value = <32-byte producer pubkey>
 *
 * 29. Filter by multiple resource limits:
 *      filter.expression = "block.header.max_compute_units > uint(1000000) && block.header.max_state_units > uint(1000) && block.header.max_block_size > uint(1000000)"
 *
 * 30. Filter blocks with high resource consumption:
 *      filter.expression = "block.footer.consumed_compute_units > uint(block.header.max_compute_units / 2)"
 *
 * Note: All filters are pushed down to SQL for optimal performance where possible.
 * When SQL pushdown is not possible, filters are evaluated in-memory on fetched results.
 *
 * @generated from message thru.services.v1.ListBlocksRequest
 */
export class ListBlocksRequest extends Message<ListBlocksRequest> {
  /**
   * CEL filter expression (OPTIONAL). See message documentation for examples.
   *
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.common.v1.PageRequest page = 2;
   */
  page?: PageRequest;

  /**
   * @generated from field: optional thru.core.v1.BlockView view = 3;
   */
  view?: BlockView;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<ListBlocksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListBlocksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 2, name: "page", kind: "message", T: PageRequest, opt: true },
    { no: 3, name: "view", kind: "enum", T: proto3.getEnumType(BlockView), opt: true },
    { no: 4, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListBlocksRequest {
    return new ListBlocksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListBlocksRequest {
    return new ListBlocksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListBlocksRequest {
    return new ListBlocksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListBlocksRequest | PlainMessage<ListBlocksRequest> | undefined, b: ListBlocksRequest | PlainMessage<ListBlocksRequest> | undefined): boolean {
    return proto3.util.equals(ListBlocksRequest, a, b);
  }
}

/**
 * ListBlocksResponse returns a page of blocks.
 *
 * @generated from message thru.services.v1.ListBlocksResponse
 */
export class ListBlocksResponse extends Message<ListBlocksResponse> {
  /**
   * @generated from field: repeated thru.core.v1.Block blocks = 1;
   */
  blocks: Block[] = [];

  /**
   * @generated from field: optional thru.common.v1.PageResponse page = 2;
   */
  page?: PageResponse;

  constructor(data?: PartialMessage<ListBlocksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListBlocksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blocks", kind: "message", T: Block, repeated: true },
    { no: 2, name: "page", kind: "message", T: PageResponse, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListBlocksResponse {
    return new ListBlocksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListBlocksResponse {
    return new ListBlocksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListBlocksResponse {
    return new ListBlocksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListBlocksResponse | PlainMessage<ListBlocksResponse> | undefined, b: ListBlocksResponse | PlainMessage<ListBlocksResponse> | undefined): boolean {
    return proto3.util.equals(ListBlocksResponse, a, b);
  }
}

/**
 * ListTransactionsForAccountRequest lists transactions involving a specific account.
 *
 * This RPC returns all transactions where the specified account appears in any
 * capacity (fee payer, signer, or affected account). Results can be filtered
 * using CEL expressions on transaction properties.
 *
 * ## Available Filter Fields
 *
 * - `transaction.slot` (uint64): Block slot number
 * - `transaction.block_offset` (uint32): Position within block
 * - `transaction.execution_result.consumed_compute_units` (uint64): Compute units used
 * - `transaction.execution_result.consumed_memory_units` (uint64): Memory units used
 * - `transaction.execution_result.consumed_state_units` (uint64): State units used
 * - `transaction.execution_result.user_error_code` (uint32): User-defined error code (0 = success)
 * - `transaction.execution_result.vm_error` (TransactionVmError enum): VM execution status
 * - `transaction.execution_result.events_count` (uint32): Number of events emitted
 * - `transaction.execution_result.events_size` (uint32): Total size of event data in bytes
 *
 * ## Filter Examples
 *
 * ### Filter by slot
 * ```
 * filter {
 *   expression: "transaction.slot == params.slot"
 *   params {
 *     key: "slot"
 *     value { int_value: 12345 }
 *   }
 * }
 * ```
 *
 * ### Filter by block offset
 * ```
 * filter {
 *   expression: "transaction.block_offset == uint(5)"
 * }
 * ```
 *
 * ### Filter by compute units (high usage)
 * ```
 * filter {
 *   expression: "transaction.execution_result.consumed_compute_units >= uint(1000000)"
 * }
 * ```
 *
 * ### Filter by memory units
 * ```
 * filter {
 *   expression: "transaction.execution_result.consumed_memory_units > uint(0)"
 * }
 * ```
 *
 * ### Filter by state units
 * ```
 * filter {
 *   expression: "transaction.execution_result.consumed_state_units > uint(0)"
 * }
 * ```
 *
 * ### Filter successful transactions (by error code)
 * ```
 * filter {
 *   expression: "transaction.execution_result.user_error_code == uint(0)"
 * }
 * ```
 *
 * ### Filter by VM execution status
 * ```
 * filter {
 *   expression: "transaction.execution_result.vm_error == int(0)"
 * }
 * ```
 *
 * ### Filter transactions with events
 * ```
 * filter {
 *   expression: "transaction.execution_result.events_count > uint(0)"
 * }
 * ```
 *
 * ### Filter by event data size
 * ```
 * filter {
 *   expression: "transaction.execution_result.events_size > uint(0)"
 * }
 * ```
 *
 * ### Check for optional fields using has()
 * ```
 * filter {
 *   expression: "has(transaction.execution_result)"
 * }
 * ```
 *
 * ### Combined filters with AND/OR
 * ```
 * filter {
 *   expression: "transaction.execution_result.consumed_compute_units >= uint(1000000) && transaction.execution_result.user_error_code == uint(0)"
 * }
 * ```
 *
 * ### Using params for dynamic values
 * ```
 * filter {
 *   expression: "transaction.execution_result.consumed_compute_units >= params.u64"
 *   params {
 *     key: "u64"
 *     value { int_value: 500000 }
 *   }
 * }
 * ```
 *
 * ## Available Functions
 *
 * - `has(field)`: Check if optional field is present
 * - `uint(value)`: Convert to unsigned integer
 * - `int(value)`: Convert to signed integer
 *
 * ## Performance Notes
 *
 * Filters on `transaction.slot`, `transaction.block_offset`, and
 * `transaction.execution_result.*` fields are optimized with SQL pushdown
 * for better performance. Complex expressions may fall back to in-memory evaluation.
 *
 * @generated from message thru.services.v1.ListTransactionsForAccountRequest
 */
export class ListTransactionsForAccountRequest extends Message<ListTransactionsForAccountRequest> {
  /**
   * @generated from field: thru.common.v1.Pubkey account = 1;
   */
  account?: Pubkey;

  /**
   * @generated from field: optional thru.common.v1.PageRequest page = 2;
   */
  page?: PageRequest;

  /**
   * Optional CEL filter applied after the account constraint.
   *
   * @generated from field: optional thru.common.v1.Filter filter = 3;
   */
  filter?: Filter;

  constructor(data?: PartialMessage<ListTransactionsForAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListTransactionsForAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: Pubkey },
    { no: 2, name: "page", kind: "message", T: PageRequest, opt: true },
    { no: 3, name: "filter", kind: "message", T: Filter, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTransactionsForAccountRequest {
    return new ListTransactionsForAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTransactionsForAccountRequest {
    return new ListTransactionsForAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTransactionsForAccountRequest {
    return new ListTransactionsForAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListTransactionsForAccountRequest | PlainMessage<ListTransactionsForAccountRequest> | undefined, b: ListTransactionsForAccountRequest | PlainMessage<ListTransactionsForAccountRequest> | undefined): boolean {
    return proto3.util.equals(ListTransactionsForAccountRequest, a, b);
  }
}

/**
 * ListTransactionsForAccountResponse contains transaction data.
 *
 * The `signatures` field is provided for backward compatibility. New clients
 * should use the `transactions` field which contains full transaction details.
 *
 * @generated from message thru.services.v1.ListTransactionsForAccountResponse
 */
export class ListTransactionsForAccountResponse extends Message<ListTransactionsForAccountResponse> {
  /**
   * @generated from field: repeated thru.common.v1.Signature signatures = 1;
   */
  signatures: Signature[] = [];

  /**
   * @generated from field: optional thru.common.v1.PageResponse page = 2;
   */
  page?: PageResponse;

  /**
   * @generated from field: repeated thru.core.v1.Transaction transactions = 3;
   */
  transactions: Transaction[] = [];

  constructor(data?: PartialMessage<ListTransactionsForAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListTransactionsForAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signatures", kind: "message", T: Signature, repeated: true },
    { no: 2, name: "page", kind: "message", T: PageResponse, opt: true },
    { no: 3, name: "transactions", kind: "message", T: Transaction, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTransactionsForAccountResponse {
    return new ListTransactionsForAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTransactionsForAccountResponse {
    return new ListTransactionsForAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTransactionsForAccountResponse {
    return new ListTransactionsForAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListTransactionsForAccountResponse | PlainMessage<ListTransactionsForAccountResponse> | undefined, b: ListTransactionsForAccountResponse | PlainMessage<ListTransactionsForAccountResponse> | undefined): boolean {
    return proto3.util.equals(ListTransactionsForAccountResponse, a, b);
  }
}

/**
 * GetVersionRequest fetches component version strings.
 *
 * @generated from message thru.services.v1.GetVersionRequest
 */
export class GetVersionRequest extends Message<GetVersionRequest> {
  constructor(data?: PartialMessage<GetVersionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetVersionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVersionRequest {
    return new GetVersionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVersionRequest {
    return new GetVersionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVersionRequest {
    return new GetVersionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetVersionRequest | PlainMessage<GetVersionRequest> | undefined, b: GetVersionRequest | PlainMessage<GetVersionRequest> | undefined): boolean {
    return proto3.util.equals(GetVersionRequest, a, b);
  }
}

/**
 * GetVersionResponse returns version information per component.
 *
 * @generated from message thru.services.v1.GetVersionResponse
 */
export class GetVersionResponse extends Message<GetVersionResponse> {
  /**
   * @generated from field: map<string, string> versions = 1;
   */
  versions: { [key: string]: string } = {};

  constructor(data?: PartialMessage<GetVersionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetVersionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "versions", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVersionResponse {
    return new GetVersionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVersionResponse {
    return new GetVersionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVersionResponse {
    return new GetVersionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetVersionResponse | PlainMessage<GetVersionResponse> | undefined, b: GetVersionResponse | PlainMessage<GetVersionResponse> | undefined): boolean {
    return proto3.util.equals(GetVersionResponse, a, b);
  }
}

/**
 * GetEventRequest fetches an event by identifier.
 *
 * @generated from message thru.services.v1.GetEventRequest
 */
export class GetEventRequest extends Message<GetEventRequest> {
  /**
   * @generated from field: string event_id = 1;
   */
  eventId = "";

  /**
   * @generated from field: optional thru.common.v1.VersionContext version_context = 2;
   */
  versionContext?: VersionContext;

  constructor(data?: PartialMessage<GetEventRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetEventRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version_context", kind: "message", T: VersionContext, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEventRequest {
    return new GetEventRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEventRequest {
    return new GetEventRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEventRequest {
    return new GetEventRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetEventRequest | PlainMessage<GetEventRequest> | undefined, b: GetEventRequest | PlainMessage<GetEventRequest> | undefined): boolean {
    return proto3.util.equals(GetEventRequest, a, b);
  }
}

/**
 * Event represents a transaction event emitted by the chain.
 *
 * @generated from message thru.services.v1.Event
 */
export class Event extends Message<Event> {
  /**
   * @generated from field: string event_id = 1;
   */
  eventId = "";

  /**
   * @generated from field: thru.common.v1.Signature transaction_signature = 2;
   */
  transactionSignature?: Signature;

  /**
   * @generated from field: optional thru.common.v1.Pubkey program = 3;
   */
  program?: Pubkey;

  /**
   * @generated from field: optional bytes payload = 4;
   */
  payload?: Uint8Array;

  /**
   * @generated from field: optional uint64 slot = 5;
   */
  slot?: bigint;

  /**
   * @generated from field: optional uint32 call_idx = 6;
   */
  callIdx?: number;

  /**
   * @generated from field: optional uint32 program_idx = 7;
   */
  programIdx?: number;

  /**
   * @generated from field: optional uint32 payload_size = 8;
   */
  payloadSize?: number;

  /**
   * @generated from field: optional uint32 block_offset = 9;
   */
  blockOffset?: number;

  /**
   * @generated from field: optional google.protobuf.Timestamp timestamp = 10;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<Event>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.Event";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "transaction_signature", kind: "message", T: Signature },
    { no: 3, name: "program", kind: "message", T: Pubkey, opt: true },
    { no: 4, name: "payload", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 6, name: "call_idx", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 7, name: "program_idx", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 8, name: "payload_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 9, name: "block_offset", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 10, name: "timestamp", kind: "message", T: Timestamp, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event {
    return new Event().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJsonString(jsonString, options);
  }

  static equals(a: Event | PlainMessage<Event> | undefined, b: Event | PlainMessage<Event> | undefined): boolean {
    return proto3.util.equals(Event, a, b);
  }
}

/**
 * ListEventsRequest lists events with CEL filtering and pagination.
 *
 * Returns events ordered from most recent to older (slot DESC, block_offset DESC, call_idx DESC).
 * Supports filtering on event metadata and payload using CEL expressions with specialized byte functions.
 *
 * Available fields for filtering:
 *   - event.event_id (string): Unique event identifier (format: "ts{slot}_{block_offset}_{call_idx}")
 *   - event.transaction_signature.value (bytes): Transaction signature that emitted the event
 *   - event.slot (uint64): Block slot number where event was emitted
 *   - event.call_idx (uint32): Instruction call index within transaction
 *   - event.block_offset (uint32): Transaction's position within the block
 *   - event.timestamp (google.protobuf.Timestamp): Event emission timestamp
 *   - event.program.value (bytes): Program public key that emitted the event
 *   - event.payload (bytes): Event payload data
 *
 * Available CEL functions:
 *   - has(field): Check if optional field exists
 *   - startsWith(string, prefix): Check if string starts with prefix (string fields only)
 *   - first1Byte(bytes): Extract first byte as uint8
 *   - first4Bytes(bytes): Extract first 4 bytes as uint32 (little-endian)
 *   - first8Bytes(bytes): Extract first 8 bytes as uint64 (little-endian)
 *   - bytesPrefix(bytes, prefix): Check if bytes start with prefix
 *   - uint(value): Convert to uint type
 *   - int(value): Convert to int type
 *   - string(value): Convert to string type
 *   - bytes(value): Convert to bytes type
 *   - double(value): Convert to double type
 *   - timestamp(value): Convert to timestamp type
 *   - duration(value): Convert to duration type
 *
 * Available filter parameters (accessible via params.* in expressions):
 *   - params.slot (uint64): Slot number for filtering
 *   - params.u64 (uint64): Generic uint64 parameter for payload matching
 *   - params.signature.value (bytes): Transaction signature for filtering
 *   - params.address.value (bytes): Program address for filtering
 *   - params.prefix (bytes): Byte prefix for payload filtering
 *
 * Filter examples:
 *
 * 1. Filter by slot:
 *      filter.expression = "event.slot > uint(1000)"
 *      filter.expression = "event.slot >= uint(100) && event.slot <= uint(200)"
 *
 * 2. Filter by slot using parameter:
 *      filter.expression = "event.slot >= params.slot"
 *      filter.params["slot"].int_value = 1234
 *
 * 3. Filter by call index:
 *      filter.expression = "event.call_idx == uint(0)"  // First instruction
 *      filter.expression = "event.call_idx > uint(0)"   // Nested instructions
 *
 * 4. Filter by block offset:
 *      filter.expression = "event.block_offset >= uint(0)"
 *      filter.expression = "event.block_offset == uint(5)"
 *
 * 5. Filter by transaction signature (using parameter):
 *      filter.expression = "event.transaction_signature.value == params.signature"
 *      filter.params["signature"].signature_value.value = <64-byte signature>
 *
 * 6. Filter by program address (using parameter):
 *      filter.expression = "has(event.program) && event.program.value == params.address"
 *      filter.params["address"].pubkey_value.value = <32-byte program pubkey>
 *
 * 7. Filter by event ID prefix using startsWith:
 *      filter.expression = "event.event_id.startsWith(\"ts\")"
 *      filter.expression = "event.event_id.startsWith(\"ts1000_\")"
 *
 * 8. Check for payload existence:
 *      filter.expression = "has(event.payload)"
 *
 * 9. Check for program existence:
 *      filter.expression = "has(event.program)"
 *
 * 10. Filter by payload first byte (event type):
 *      filter.expression = "has(event.payload) && first1Byte(event.payload) == uint(1)"  // MESSAGE events
 *      filter.expression = "has(event.payload) && first1Byte(event.payload) == uint(2)"  // Other type
 *
 * 11. Filter by payload first 4 bytes (uint32 event type):
 *      filter.expression = "has(event.payload) && first4Bytes(event.payload) == uint(2)"  // COUNTER events
 *      filter.expression = "has(event.payload) && first4Bytes(event.payload) == params.u64"
 *      filter.params["u64"].int_value = 2
 *
 * 12. Filter by payload first 8 bytes (uint64 event type):
 *      filter.expression = "has(event.payload) && first8Bytes(event.payload) == uint(6)"  // PATTERN events
 *      filter.expression = "has(event.payload) && first8Bytes(event.payload) == params.u64"
 *      filter.params["u64"].int_value = 6
 *
 * 13. Filter by payload byte prefix:
 *      filter.expression = "bytesPrefix(event.payload, params.prefix)"
 *      filter.params["prefix"].bytes_value = <byte prefix to match>
 *
 * 14. Combine slot and call_idx filters:
 *      filter.expression = "event.slot > uint(1000) && event.call_idx == uint(0)"
 *
 * 15. Combine slot, call_idx, and payload existence:
 *      filter.expression = "event.slot > uint(1000) && event.call_idx == uint(0) && has(event.payload)"
 *
 * 16. Filter by program and payload type:
 *      filter.expression = "has(event.program) && event.program.value == params.address && first1Byte(event.payload) == uint(1)"
 *      filter.params["address"].pubkey_value.value = <32-byte program pubkey>
 *
 * 17. Filter MESSAGE events (type 1) with specific program:
 *      filter.expression = "has(event.payload) && first1Byte(event.payload) == uint(1) && event.program.value == params.address"
 *      filter.params["address"].pubkey_value.value = <32-byte program pubkey>
 *
 * 18. Filter COUNTER events (type 2) in slot range:
 *      filter.expression = "has(event.payload) && first4Bytes(event.payload) == uint(2) && event.slot >= uint(100) && event.slot <= uint(200)"
 *
 * 19. Filter PATTERN events (type 6) with payload prefix:
 *      filter.expression = "has(event.payload) && first8Bytes(event.payload) == uint(6) && bytesPrefix(event.payload, params.prefix)"
 *      filter.params["prefix"].bytes_value = <pattern prefix bytes>
 *
 * 20. Complex combined filter:
 *      filter.expression = "(event.slot > uint(1000) && event.call_idx == uint(0)) || first1Byte(event.payload) == uint(1)"
 *
 * 21. Filter events from specific transaction:
 *      filter.expression = "event.transaction_signature.value == params.signature && has(event.payload)"
 *      filter.params["signature"].signature_value.value = <64-byte signature>
 *
 * 22. Filter by multiple payload type options:
 *      filter.expression = "has(event.payload) && (first1Byte(event.payload) == uint(1) || first1Byte(event.payload) == uint(2))"
 *
 * 23. Filter nested instruction events:
 *      filter.expression = "event.call_idx > uint(0) && has(event.program)"
 *
 * 24. Filter first instruction events only:
 *      filter.expression = "event.call_idx == uint(0)"
 *
 * 25. Filter events with payload longer than specific size (using bytesPrefix with empty prefix):
 *      filter.expression = "has(event.payload)"
 *
 * 26. Combine has() checks:
 *      filter.expression = "has(event.program) && has(event.payload) && has(event.timestamp)"
 *
 * 27. Use inequality operators:
 *      filter.expression = "event.slot < uint(10000)"
 *      filter.expression = "event.slot <= uint(10000)"
 *      filter.expression = "event.call_idx >= uint(0)"
 *      filter.expression = "event.block_offset != uint(0)"
 *
 * 28. Filter by timestamp (if available):
 *      filter.expression = "has(event.timestamp)"
 *
 * 29. Match specific event ID pattern:
 *      filter.expression = "event.event_id.startsWith(\"ts1234_0_\")"
 *
 * 30. Complex payload and metadata filter:
 *      filter.expression = "event.slot >= params.slot && has(event.payload) && first8Bytes(event.payload) == params.u64 && event.program.value == params.address"
 *      filter.params["slot"].int_value = 1000
 *      filter.params["u64"].int_value = 6
 *      filter.params["address"].pubkey_value.value = <32-byte program pubkey>
 *
 * Note: Filters on slot, call_idx, block_offset, transaction_signature, and program are pushed down to SQL
 * for optimal performance. Payload filters (first1Byte, first4Bytes, first8Bytes, bytesPrefix) are evaluated
 * in-memory on fetched results.
 *
 * @generated from message thru.services.v1.ListEventsRequest
 */
export class ListEventsRequest extends Message<ListEventsRequest> {
  /**
   * CEL filter expression (OPTIONAL). See message documentation for examples.
   *
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.common.v1.PageRequest page = 2;
   */
  page?: PageRequest;

  /**
   * @generated from field: optional thru.common.v1.VersionContext version_context = 3;
   */
  versionContext?: VersionContext;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 4;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<ListEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 2, name: "page", kind: "message", T: PageRequest, opt: true },
    { no: 3, name: "version_context", kind: "message", T: VersionContext, opt: true },
    { no: 4, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEventsRequest {
    return new ListEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEventsRequest {
    return new ListEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEventsRequest {
    return new ListEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListEventsRequest | PlainMessage<ListEventsRequest> | undefined, b: ListEventsRequest | PlainMessage<ListEventsRequest> | undefined): boolean {
    return proto3.util.equals(ListEventsRequest, a, b);
  }
}

/**
 * ListEventsResponse returns paginated events.
 *
 * @generated from message thru.services.v1.ListEventsResponse
 */
export class ListEventsResponse extends Message<ListEventsResponse> {
  /**
   * @generated from field: repeated thru.services.v1.Event events = 1;
   */
  events: Event[] = [];

  /**
   * @generated from field: optional thru.common.v1.PageResponse page = 2;
   */
  page?: PageResponse;

  constructor(data?: PartialMessage<ListEventsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListEventsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: Event, repeated: true },
    { no: 2, name: "page", kind: "message", T: PageResponse, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEventsResponse {
    return new ListEventsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEventsResponse {
    return new ListEventsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEventsResponse {
    return new ListEventsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListEventsResponse | PlainMessage<ListEventsResponse> | undefined, b: ListEventsResponse | PlainMessage<ListEventsResponse> | undefined): boolean {
    return proto3.util.equals(ListEventsResponse, a, b);
  }
}

/**
 * ListTransactionsRequest lists executed transactions with CEL filtering and pagination.
 *
 * Returns transactions ordered from most recent to older (slot DESC, block_offset DESC).
 * Supports filtering on transaction metadata and execution results using CEL expressions.
 *
 * Available fields for filtering:
 *   - transaction.slot (uint64): Block slot number where transaction was executed
 *   - transaction.block_offset (uint32): Transaction's position within the block
 *   - transaction.signature.value (bytes): Transaction signature
 *   - transaction.execution_result.vm_error (int32): VM error code (0 = success)
 *   - transaction.execution_result.user_error_code (uint64): User-defined error code
 *   - transaction.execution_result.consumed_compute_units (uint64): Compute units consumed
 *   - transaction.execution_result.consumed_memory_units (uint64): Memory units consumed
 *   - transaction.execution_result.consumed_state_units (uint64): State units consumed
 *   - transaction.execution_result.events_count (uint32): Number of events emitted
 *   - transaction.execution_result.events_size (uint32): Total size of events in bytes
 *
 * Available CEL functions:
 *   - has(field): Check if optional field exists
 *   - uint(value): Convert to uint type
 *   - int(value): Convert to int type
 *
 * Available filter parameters (accessible via params.* in expressions):
 *   - params.slot (uint64): Slot number for filtering
 *   - params.u64 (uint64): Generic uint64 parameter
 *
 * Filter examples:
 *
 * 1. Filter by slot range:
 *      filter.expression = "transaction.slot >= uint(1000) && transaction.slot <= uint(2000)"
 *
 * 2. Filter by successful transactions (no error):
 *      filter.expression = "transaction.execution_result.user_error_code == uint(0)"
 *      filter.expression = "transaction.execution_result.vm_error == int(0)"
 *
 * 3. Filter by specific VM error:
 *      filter.expression = "transaction.execution_result.vm_error == int(2)"  // VM_REVERT
 *      filter.expression = "transaction.execution_result.vm_error == int(4)"  // NONCE_TOO_LOW
 *      filter.expression = "transaction.execution_result.vm_error == int(5)"  // NONCE_TOO_HIGH
 *
 * 4. Filter by resource usage:
 *      filter.expression = "transaction.execution_result.consumed_compute_units > uint(1000)"
 *      filter.expression = "transaction.execution_result.consumed_memory_units > uint(0)"
 *      filter.expression = "transaction.execution_result.consumed_state_units >= uint(0)"
 *
 * 5. Filter by compute units range:
 *      filter.expression = "transaction.execution_result.consumed_compute_units >= uint(0) && transaction.execution_result.consumed_compute_units < uint(1000000)"
 *
 * 6. Filter by events count:
 *      filter.expression = "transaction.execution_result.events_count == uint(0)"  // No events (transfers)
 *      filter.expression = "transaction.execution_result.events_count > uint(0)"   // Has events
 *      filter.expression = "transaction.execution_result.events_count == uint(1)"  // Exactly 1 event
 *
 * 7. Filter by events size:
 *      filter.expression = "transaction.execution_result.events_size == uint(0)"  // No events
 *      filter.expression = "transaction.execution_result.events_size > uint(0)"   // Has events
 *      filter.expression = "transaction.execution_result.events_size >= uint(100)" // Large events
 *      filter.expression = "transaction.execution_result.events_size >= uint(50) && transaction.execution_result.events_size <= uint(200)"
 *
 * 8. Filter by block offset:
 *      filter.expression = "transaction.block_offset >= uint(0)"
 *      filter.expression = "transaction.block_offset == uint(5)"
 *
 * 9. Combine multiple conditions with AND:
 *      filter.expression = "transaction.execution_result.user_error_code == uint(0) && transaction.execution_result.consumed_compute_units > uint(0)"
 *
 * 10. Combine multiple conditions with OR:
 *      filter.expression = "transaction.execution_result.user_error_code == uint(0) || transaction.execution_result.user_error_code != uint(0)"
 *      filter.expression = "transaction.execution_result.vm_error == int(2) || transaction.execution_result.vm_error == int(4)"
 *
 * 11. Complex combined filters:
 *      filter.expression = "(transaction.slot >= uint(0) && transaction.execution_result.user_error_code == uint(0)) || transaction.execution_result.consumed_compute_units > uint(100000)"
 *
 * 12. Check for field existence:
 *      filter.expression = "has(transaction.execution_result)"
 *
 * 13. Use inequality operators:
 *      filter.expression = "transaction.execution_result.consumed_compute_units < uint(1000000)"
 *      filter.expression = "transaction.execution_result.consumed_compute_units <= uint(1000000)"
 *      filter.expression = "transaction.execution_result.consumed_compute_units >= uint(0)"
 *      filter.expression = "transaction.execution_result.user_error_code != uint(999)"
 *
 * 14. Use params.slot parameter:
 *      filter.expression = "transaction.slot == params.slot"
 *      filter.params["slot"].uint_value = 1234
 *
 * 15. Use params.u64 with type conversion:
 *      filter.expression = "transaction.execution_result.consumed_compute_units < uint(params.u64)"
 *      filter.params["u64"].uint_value = 1000000
 *
 * The return_events flag controls whether event data is included in the response:
 *   - return_events = false (default): Only event counts/sizes are returned, not actual event data
 *   - return_events = true: Full event data is included in execution results
 *
 * Note: All filters are pushed down to SQL for optimal performance where possible.
 *
 * @generated from message thru.services.v1.ListTransactionsRequest
 */
export class ListTransactionsRequest extends Message<ListTransactionsRequest> {
  /**
   * CEL filter expression (OPTIONAL). See message documentation for examples.
   *
   * @generated from field: optional thru.common.v1.Filter filter = 1;
   */
  filter?: Filter;

  /**
   * @generated from field: optional thru.common.v1.PageRequest page = 2;
   */
  page?: PageRequest;

  /**
   * Whether to include event data in results (default: false)
   *
   * @generated from field: optional bool return_events = 3;
   */
  returnEvents?: boolean;

  /**
   * @generated from field: optional thru.common.v1.VersionContext version_context = 4;
   */
  versionContext?: VersionContext;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus min_consensus = 5;
   */
  minConsensus?: ConsensusStatus;

  constructor(data?: PartialMessage<ListTransactionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListTransactionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 2, name: "page", kind: "message", T: PageRequest, opt: true },
    { no: 3, name: "return_events", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "version_context", kind: "message", T: VersionContext, opt: true },
    { no: 5, name: "min_consensus", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListTransactionsRequest | PlainMessage<ListTransactionsRequest> | undefined, b: ListTransactionsRequest | PlainMessage<ListTransactionsRequest> | undefined): boolean {
    return proto3.util.equals(ListTransactionsRequest, a, b);
  }
}

/**
 * ListTransactionsResponse returns paginated executed transactions.
 *
 * @generated from message thru.services.v1.ListTransactionsResponse
 */
export class ListTransactionsResponse extends Message<ListTransactionsResponse> {
  /**
   * @generated from field: repeated thru.core.v1.Transaction transactions = 1;
   */
  transactions: Transaction[] = [];

  /**
   * @generated from field: optional thru.common.v1.PageResponse page = 2;
   */
  page?: PageResponse;

  constructor(data?: PartialMessage<ListTransactionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.ListTransactionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactions", kind: "message", T: Transaction, repeated: true },
    { no: 2, name: "page", kind: "message", T: PageResponse, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTransactionsResponse {
    return new ListTransactionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTransactionsResponse {
    return new ListTransactionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTransactionsResponse {
    return new ListTransactionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListTransactionsResponse | PlainMessage<ListTransactionsResponse> | undefined, b: ListTransactionsResponse | PlainMessage<ListTransactionsResponse> | undefined): boolean {
    return proto3.util.equals(ListTransactionsResponse, a, b);
  }
}

/**
 * GetTransactionStatusRequest fetches execution status for a transaction.
 *
 * @generated from message thru.services.v1.GetTransactionStatusRequest
 */
export class GetTransactionStatusRequest extends Message<GetTransactionStatusRequest> {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetTransactionStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetTransactionStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTransactionStatusRequest {
    return new GetTransactionStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTransactionStatusRequest {
    return new GetTransactionStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTransactionStatusRequest {
    return new GetTransactionStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTransactionStatusRequest | PlainMessage<GetTransactionStatusRequest> | undefined, b: GetTransactionStatusRequest | PlainMessage<GetTransactionStatusRequest> | undefined): boolean {
    return proto3.util.equals(GetTransactionStatusRequest, a, b);
  }
}

/**
 * TransactionStatus captures status metadata for a transaction.
 *
 * @generated from message thru.services.v1.TransactionStatus
 */
export class TransactionStatus extends Message<TransactionStatus> {
  /**
   * @generated from field: thru.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from field: optional thru.common.v1.ConsensusStatus consensus_status = 2;
   */
  consensusStatus?: ConsensusStatus;

  /**
   * @generated from field: optional thru.core.v1.TransactionExecutionResult execution_result = 3;
   */
  executionResult?: TransactionExecutionResult;

  constructor(data?: PartialMessage<TransactionStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.TransactionStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "message", T: Signature },
    { no: 2, name: "consensus_status", kind: "enum", T: proto3.getEnumType(ConsensusStatus), opt: true },
    { no: 3, name: "execution_result", kind: "message", T: TransactionExecutionResult, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionStatus {
    return new TransactionStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionStatus {
    return new TransactionStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionStatus {
    return new TransactionStatus().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionStatus | PlainMessage<TransactionStatus> | undefined, b: TransactionStatus | PlainMessage<TransactionStatus> | undefined): boolean {
    return proto3.util.equals(TransactionStatus, a, b);
  }
}

/**
 *
 *
 * @generated from message thru.services.v1.GetHeightRequest
 */
export class GetHeightRequest extends Message<GetHeightRequest> {
  constructor(data?: PartialMessage<GetHeightRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetHeightRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHeightRequest {
    return new GetHeightRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHeightRequest {
    return new GetHeightRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHeightRequest {
    return new GetHeightRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetHeightRequest | PlainMessage<GetHeightRequest> | undefined, b: GetHeightRequest | PlainMessage<GetHeightRequest> | undefined): boolean {
    return proto3.util.equals(GetHeightRequest, a, b);
  }
}

/**
 * GetHeightResponse
 *
 * @generated from message thru.services.v1.GetHeightResponse
 */
export class GetHeightResponse extends Message<GetHeightResponse> {
  /**
   * @generated from field: uint64 finalized = 1;
   */
  finalized = protoInt64.zero;

  /**
   * @generated from field: uint64 locally_executed = 2;
   */
  locallyExecuted = protoInt64.zero;

  /**
   * @generated from field: uint64 cluster_executed = 3;
   */
  clusterExecuted = protoInt64.zero;

  constructor(data?: PartialMessage<GetHeightResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "thru.services.v1.GetHeightResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "finalized", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "locally_executed", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "cluster_executed", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHeightResponse {
    return new GetHeightResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHeightResponse {
    return new GetHeightResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHeightResponse {
    return new GetHeightResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetHeightResponse | PlainMessage<GetHeightResponse> | undefined, b: GetHeightResponse | PlainMessage<GetHeightResponse> | undefined): boolean {
    return proto3.util.equals(GetHeightResponse, a, b);
  }
}

